<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Vue]]></title>
    <url>%2Fblog%2F2018%2F10%2F08%2FVue%2F</url>
    <content type="text"><![CDATA[Vue created monuted computed methods阶段说明created运行时，还未挂载到DOM，不能访问到$el属性，可用于初始化一些数据，但和DOM操作相关的不能在created中执行。monuted运行时，实例已经挂在到DOM，此时可以通过DOM API获取到DOM节点。computed是在HTML DOM加载后马上执行的，如赋值。methods必须要有一定的触发条件才能执行，如点击事件。参见：Vue生命周期 dev模式跨域访问 默认禁止跨域访问Failed to load http://localhost:8081/api/product/getParam.do: No ‘Access-Control-Allow-Origin’ header is present on the requested resource. Origin ‘http://localhost:8082&#39; is therefore not allowed access. 跨域设置在 config 目录下有个 index.js 文件 在 proxyTable{} 中设置跨域12345678910 proxyTable: &#123; '/API':&#123;//此处并非一定和url一致。 target:'http://localhost:8081', changeOrigin:true,//允许跨域 pathRewrite:&#123; '^/API': '' &#125; &#125; &#125;,此段代码表示，如果请求地址以/API开头，则自动加上target。即 http://localhost:8081/API pathRewrite 是重写路径 如果不需要 /API 则配置 '' 替换,配置完后需要重启 Promise说明Promise的构造函数接受一个参数(函数)；并且传入两个参数：resolve,reject，分别表示异步操作执行成功后的回调函数和异步操作执行失败后的回调函数。Promise用法Promise官方 axios封装 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061/** * Created by wyb on 2018/9/30. * axios封装 request/response拦截器、并发等需要的时候加入 * 参见[axios](https://www.npmjs.com/package/axios) */import axios from 'axios'import &#123; Toast &#125; from 'mint-ui';function HttpServer(method, url, data) &#123; if(!url)&#123; Toast("请求路径错误，请检查"); &#125; var config = &#123;&#125;; config.url = url; switch (method) &#123; case 'get' : config.method = 'GET'; if (data) &#123; config.params = data; &#125; break; case 'post' : config.method = 'POST'; config.data = data; break; case 'delete' : config.method = 'DELETE'; break; default : config.method = 'GET'; break; &#125; return new Promise((resolve, reject) =&gt; &#123; axios(config) .then(result =&gt; &#123; //TODO &#125;, err =&gt; &#123; console.log(err); &#125;) .catch((error) =&gt; &#123; //TODO &#125;) &#125;)&#125;export default &#123; get (url,params) &#123; return HttpServer('get',url,params); &#125;, post (url,data) &#123; return HttpServer('post',url,params); &#125;, delete (url,) &#123; return HttpServer('delete',url,null); &#125;&#125; 封装好的 axios 在 main.js 中挂载到 vue 的原型上，这样就能整个项目中随意使用了 this.HttpServer.get(xxxx) 。123456789101112131415161718import Vue from 'vue'import MintUI from 'mint-ui'import 'mint-ui/lib/style.css'import App from './App'import router from './router'import axios from './axios'Vue.use(MintUI);Vue.prototype.HttpServer = axios; // Vue函数添加一个原型属性 HttpServer 指向 axiosVue.config.productionTip = true;new Vue(&#123; el: '#app', router, components: &#123; App &#125;, template: '&lt;App/&gt;' //components:&#123;App&#125;,template:‘&lt;app/&gt;’等价于 render: h =&gt; h(App)&#125;) 不添加原型属性则不能使用，会报未定义错误 eg: [Vue warn]: Error in created hook: “TypeError: Cannot read property ‘get’ of undefined” Vue.prototype.xxx = xxx 和 Vue.use(xxx) 区别 不是vue的插件(插件内要处理)不支持Vue.use()加载方式 非vue官方库不支持new Vue()方式 每一个vue组件都是Vue的实例，所以组件内this可以拿到Vue.prototype上添加的属性和方法。 在$http返回回调中，this指向的是$http对象而非Vue实例 123456789101112131415161718192021222324252627282930this.HttpServer.get(url,params) .then(function (response) &#123; //成功后跳转到index界面 this.$router.push(&#123; // 这个地方的this并不指向vue实例,指向的是HttpServer对象 path: '/index' &#125;)&#125;).catch(function (response) &#123; console.error(response);&#125;);方式一： let self = this; // 定义一个变量指向vue实例this.HttpServer.get(url,params) .then(function (response) &#123; //成功后跳转到index界面 self.$router.push(&#123; path: '/index' &#125;)&#125;).catch(function (response) &#123; console.error(response);&#125;);方式二：this.HttpServer.get(url,params) .then(response =&gt; &#123; //成功后跳转到index界面 this.$router.push(&#123; // 在箭头函数内部的this并不指向这个函数 而是指向vue实例 path: '/index' &#125;)&#125;).catch(function (response) &#123; console.error(response);&#125;); npm run build 打包跨域的解决方法 通过 nginx 反向代理解决 const,var,let定义变量的区别 const定义的变量不可以修改，而且必须初始化，const定义的是一个恒定的常量。var定义的变量可以修改，如果不初始化会输出undefined，不会报错。作用域是全局的或者是函数级的,没有块的概念，可以跨块访问, 不能跨函数访问。let是块级作用域(ES6中新增)，只能在块作用域里访问，不能跨块访问，也不能跨函数访问。123456789101112131415161718192021222324252627282930313233343536var 和 let 的区别 1： 同一作用域 var 可以声明已定义的变量， let 不能声明已定义的变量 var a = 1; var a = 2; console.log(a); // 2 let b = 1; //or var b =1 ; let b = 2; //Uncaught SyntaxError: Identifier 'b' has already been declared console.log(b);2：var 作用域是全局的或者是函数级的， let 作用域是块级的,即只要是在 &#123; &#125; 中声明的变量，只在该 ｛ ｝ 中有效。 var a = 1; console.log(a); // 输出 1 function qqq()&#123; var a = 2; console.log(a); // 输出 2 &#125; qqq(); console.log(a); // 输出 1 let b = 1; console.log(b); // 输出 1 &#123; let b = 2; console.log(b); // 输出 2 function qqq()&#123; b = 3; console.log(b); // 输出 3 &#125; qqq(); console.log(b); // 输出 3 &#125; console.log(b); // 输出 1 给一个没有声明的变量赋值 = 隐式申明一个全局变量 eg： c = 1 即全局变量 记录 vue 项目打包的一些事情 转自 https://www.cnblogs.com/Grewer/p/8847636.html 首先声明项目都是由 vue-cli 生成; vue 项目从 dev 切换到 prod 时有很多地方需要注意; 1.首先是大家最需要注意的 ajax 切换环节以前一开始用 Vue 的时候我是在 build 之后,手动修改 ajax 的请求前缀比如现在我使用的 axios,axios.defaults.baseURL = ‘api’但是打包的时候一般都要改动 url,直到我后来知道了 process.env 这个对象,使用他可以获取当前的环境(后续还会提到,如何修改这个对象)之后就可以轻松的修改 ajax 的基础路径了:axios.defaults.baseURL = process.env.NODE_ENV === ‘development’ ? ‘api’ : ‘’ 使用该方法能够无需在打包时修改路径,更好地配合 webpack 的 proxyTable; 2.与 1 类似的 Vue.config.devtools 同样地使用 process 来解决这个问题, Vue.config.devtools = process.env.NODE_ENV === ‘development’该属性是是否能够打开 vue 的 devTools; 某个小有名气的网站,vue 上线的时候,还是 dev 环境,大家引以为戒吧 3.sources里的 webpack:// 大家在运行程序的时候可以打开 chrome 的 sources 点击 webpack:// 可以发现这个对象里,有所有在运行的组件,资源的源码;这个是为了在 debug 的时候调试,然而在 build 之后这个仍然会存在与 sources 中留下很大的隐患; 而解决这个的方法就是在 /config/index.js 文件下 build 对象中的productionSourceMap改为:productionSourceMap:false在 build 之前需要检查一下该属性; 4.build 之后需要相对路径的引用: 也许大家都知道了,在一般项目 build 之后都会生成一个 index.htm 文件和 一个 static 文件夹,而 static 这个文件夹需要被放置在根目录下,index.html 会在决定路径下引用该文件如果需要添加模块的话,只需要在 /config/index.js 文件下的 build 对象下,修改 assetsSubDirectory 属性为:assetsSubDirectory: ‘static/[模块名]’很多人引用图片, css 时也都是在 static 文件夹里面引用的,所以绝对引用也没有太多的问题;回到正题,如果图片,css 都是在 assets文件里面, build 之后的文件需要相对路径的引用,这个情况也是比较多的:assetsSubDirectory这个属性可以像我上面说的那样,再修改 assetsPublicPath 为 ‘./‘ 如果还有终极的引用需求,比如我碰到的这个:index.html 放置在根目录的模块文件夹下, static 需要放置在根目录的公共static下的模块文件夹下,这里需要改的话会比较麻烦,不过我估计没什么人会和我一样碰到这样的要求,我就简单讲下,先是修改 /build/webpack.base.conf.js里图片的引用方式,再修改 /build/utils.js里的 assetsPath 函数,使其碰到图片的引用时,添加对应的路径即可;特别说明:打包后,如果你需要使用相对路径来引用,js,css,图片等资源,而且图片是放在assets中的,那么你一定会碰到图片引用错误的情况,解决该情况也比较容易:在 build/utils.js 中大概第47行的样子,修改 ExtractTextPlugin.extract 为:return ExtractTextPlugin.extract({ use: loaders, publicPath: ‘../../‘, // 仅添加该行即可 fallback: ‘vue-style-loader’ }) 5.添加自定义的全局变量: 在 /build/webpack.dev.conf.js 文件下找到 plugins 里的 DefinePlugin 如下,添加测试:new webpack.DefinePlugin({ ‘process.env’: require(‘../config/dev.env’), ‘myTest’:true })重新启动项目,在 main.js 里面打印该属性:console.log(myTest) // true可以发现 console 里输出了该属性的值 true,同样地在 /build/webpack.prod.conf.js 文件下也可以添加全局变量,可以通过改方法来替换本文中 1 里的功能,可以直接改变全局变量,而不是用当前环境来判断;]]></content>
      <categories>
        <category>Vue</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[SQL Server实例]]></title>
    <url>%2Fblog%2F2018%2F10%2F08%2FSQL%20Server%E5%AE%9E%E4%BE%8B%2F</url>
    <content type="text"><![CDATA[SQL Server实例 转自:http://bbs.51cto.com/thread-1085337-1.html实例分为两类：1.默认实例在安装SQL Server时，可以选择一个默认实例,同时此实例的名称被自动命名为MSSQLSERVER。一台机器上可以没有默认实例，最多也只能有一个默认实例。客户端连接到一个默认实例时，只需要指定安装这个实例的机器的名称。2.命名实例除了默认实例，其它的实例都是命名实例，在安装时必须给它指定一个实例名称。如果这台机器上没有默认实例，那么最多可以安装50个命名实例(SQL Server 2008)；如果已经有一个默认实例，则最多可以安装49个命名实例。客户端连接到一个命名实例时，要使用机器名与实例名的组合，例如\ 一、多实例并存的技术限制可以在已运行 SQL Server 早期版本实例的计算机上安装 SQL Server。如果计算机上已存在默认实例，则 SQL Server 必须作为命名实例安装。 SQL Server 2008最多允许在一台机器上安装50个实例。从理论上讲，只要硬件性能足够，就可以在一台机器上并存50个实例。 二、并行实例的原因在一台机器上是否并存多少个实例，没有绝对值。一般多实例并存的场景主要有以下几种： 隔离不同的管理结构和安全配置例如，某个实例要求sa帐户，另一个实例也要求sa帐户但密码不同，另一个实例禁用sa帐户。 不同的性能要求通过对每个实例的属性配置，或者通过资源调控器，可以为每个实例实现不同的内存、CPU、磁盘资源，从而实现不同的性能要求。 不同的服务等级协议（SLA）不同的数据库应用程序可能需要不同的SLA，特别是关于RTO（recovery time objective）和RPO（recovery point objectives）。例如，客户可能需要某个实例实现724运行，并且要求可以恢复到最后一笔交易；对另一个实例可能只需要58运行，并且只要求可以恢复到备份点。 不同的历史版本例如，可以将SQL Server 2005与SQL Server 2008安装在同一台机器上。这种场景尤其用于背靠背升级时。 不同的排序规则例如，某个实例为SQL_Latin1_General_CP1_CI_AS（西欧字符集），另一个实例为Chinese_PRC_CI_AS（简体中文字符集）。三、注意事项 防止端口冲突并行安装 SQL Server 实例时，请注意避免 IP 地址上的 TCP 端口号冲突。当 数据库引擎的两个实例都配置为使用默认 TCP 端口 (1433)时，通常会发生冲突。要避免冲突，请将一个实例配置为使用非默认的固定端口，或者使用动态端口。 规划硬件负载同一台机器上安装了多个并行的实例，对这台机器的硬件会有较多的竞争，需要提前规划硬件负载，以及为每个实例配置不同的硬件资源。。 Server Core 模式SQL Server 2012 不能在运行 Windows Server 2008 R2 Server Core SP1 的计算机上与早期版本的 SQL Server 一起并行安装。 SQL Server专家博主SQL Server用户指南]]></content>
      <categories>
        <category>SQL Server</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[AOP方式记录操作日志]]></title>
    <url>%2Fblog%2F2018%2F09%2F21%2FAOP%E6%96%B9%E5%BC%8F%E8%AE%B0%E5%BD%95%E6%93%8D%E4%BD%9C%E6%97%A5%E5%BF%97%2F</url>
    <content type="text"><![CDATA[AOP方式记录操作日志 一般记录操作日志有三种方式：1.使用Filter实现日志记录2.使用Interceptor实现日志记录3.使用AOP实现日志记录 Filter 和 Interceptor 说明1.Filter需要在web.xml中配置，依赖于Servlet；2.Interceptor需要在SpringMVC中配置，依赖于框架；3.Filter的执行顺序在Interceptor之前两者的本质区别：拦截器（Interceptor）是基于Java的反射机制（AOP思想），而过滤器（Filter）是基于函数回调（doFilter()方法） AOP说明AOP（Aspect Orient Programming），一般称为面向方面（切面）编程，作为面向对象的一种补充，用于处理系统中分布于各个模块的横切关注点，比如事务管理、日志、缓存等等。AOP实现的关键在于AOP框架自动创建的AOP代理，AOP代理主要分为静态代理和动态代理，静态代理的代表为AspectJ；而动态代理则以Spring AOP为代表。 使用AspectJ的编译时增强实现AOPAspectJ是静态代理的增强，所谓的静态代理就是AOP框架会在编译阶段生成AOP代理类，因此也称为编译时增强。它会在编译阶段将Aspect织入Java字节码中，运行的时候就是经过增强之后的AOP对象。 使用Spring AOP与AspectJ的静态代理不同，Spring AOP使用的动态代理，所谓的动态代理就是说AOP框架不会去修改字节码，而是在内存中临时为方法生成一个AOP对象，这个AOP对象包含了目标对象的全部方法，并且在特定的切点做了增强处理，并回调原对象的方法。Spring AOP中的动态代理主要有两种方式，JDK动态代理和CGLIB动态代理。JDK动态代理通过反射来接收被代理的类，并且要求被代理的类必须实现一个接口。JDK动态代理的核心是InvocationHandler接口和Proxy类。如果目标类没有实现接口，那么Spring AOP会选择使用CGLIB来动态代理目标类。CGLIB（Code Generation Library），是一个代码生成的类库，可以在运行时动态的生成某个类的子类，注意，CGLIB是通过继承的方式做的动态代理，因此如果某个类被标记为final，那么它是无法使用CGLIB做动态代理的。参见Spring AOP的实现原理 &lt;aop:aspect &gt;与&lt;aop:advisor &gt;的区别实现方式：&lt;aop:aspect&gt;定义切面时，只需要定义一般的bean就行，而定义&lt;aop:advisor&gt;中引用的通知时，通知必须实现Advice接口使用场景: &lt;aop:advisor&gt;大多用于事务管理。 &lt;aop:aspect&gt;大多用于日志，缓存参见&lt;aop:aspect &gt;与&lt;aop:advisor &gt;的区别 创建一个自定义注解 用于日志记录123456789@Target(ElementType.METHOD)@Retention(RetentionPolicy.RUNTIME) @Documentedpublic @interface SysLogAnnotation &#123; String module() default ""; //模块 String method() default ""; //方法&#125; @Retention 描述注解的生命周期1.SOURCE:在源文件中有效（即源文件保留）2.CLASS:在class文件中有效（即class保留）3.RUNTIME:在运行时有效（即运行时保留） @Targe 描述注解的使用范围1.CONSTRUCTOR:用于描述构造器2.FIELD:用于描述域3.LOCAL_VARIABLE:用于描述局部变量4.METHOD:用于描述方法5.PACKAGE:用于描述包6.PARAMETER:用于描述参数7.TYPE:用于描述类、接口(包括注解类型) 或enum声明8.ANNOTATION_TYPE：用于声明在一个注解类型前。JDK 1.8之后又加入了 TYPE_PARAMETER TYPE_USE @Documented 描述其它类型的annotation应该被作为被标注的程序成员的公共API，因此可以被例如javadoc此类的工具文档化。Documented是一个标记注解，没有成员。 创建切面类。下面分别介绍 基于注解方式和 基于XML的配置方式注解方式1.在springMVC配置文件中加入以下配置 &lt;aop:aspectj-autoproxy/&gt; 2.创建切面类12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970@Aspect@Componentpublic class SysLogAspect &#123; private final Logger log = LoggerFactory.getLogger(SysLogAspect.class); @Pointcut("@annotation(com.wyb.sys.log.SysLogAnnotation)") public void logPointCut() &#123; &#125; @Around("logPointCut()") public Object around(ProceedingJoinPoint point) throws Throwable &#123; long beginTime = System.currentTimeMillis(); //执行方法 Map result = (Map) point.proceed(); //执行时长(毫秒) long time = System.currentTimeMillis() - beginTime; System.out.println(result); //保存日志 saveSysLog(point,result,time); return result; &#125; private void saveSysLog(ProceedingJoinPoint joinPoint,Map result,long time)&#123; try&#123; MethodSignature signature = (MethodSignature) joinPoint.getSignature(); Method method = signature.getMethod(); SysLogAnnotation sysLogAnnotation = method.getAnnotation(SysLogAnnotation.class); if(sysLogAnnotation == null)&#123; return; &#125; SysLog sysLog = new SysLog(); //注解上的值 sysLog.setModule(sysLogAnnotation.module()); sysLog.setMethod(sysLogAnnotation.method()); //请求的方法名 String className = joinPoint.getTarget().getClass().getName(); String methodName = signature.getName(); sysLog.setClassFullName(className + "." + methodName); //设置IP地址 HttpServletRequest request = ((ServletRequestAttributes) RequestContextHolder.getRequestAttributes()).getRequest(); sysLog.setIp(IpUtil.getIpAddr(request)); //请求的参数 Object[] args = joinPoint.getArgs(); sysLog.setParams(JSON.toJSONString(args)); //用户信息 SessionUser sessionUser = ShiroUtils.getSessionUser(); if(sessionUser!=null)&#123; sysLog.setUserId(sessionUser.getId()); sysLog.setUserName(sessionUser.getName()); sysLog.setLoginName(sessionUser.getLoginName()); &#125; sysLog.setTime(time); sysLog.setCreateDate(new Date()); System.out.println(JSON.toJSONString(sysLog)); &#125;catch (Exception e)&#123; e.getMessage(); log.error(e.getMessage()); &#125; &#125;&#125; 3.切面类注解说明@Aspect 声明切面，修饰切面类，从而获得通知@PointCut 切入点，修饰方法 private void xxx(){} 之后通过“方法名”获得切入点引用@Before 前置通知，在目标方法开始之前执行@After 后置通知, 在方法执行之后执行@AfterReturning 返回通知,在方法返回结果之后执行@AfterThrowing 抛出异常@Around 环绕 注意：环绕通知内部一定要确保执行proceed()该方法，如果不执行该方法，业务bean中被拦截的方法就不会被执行。当执行该方法，如果后面还有切面的话，它的执行顺序应该是这样的：先执行后面的切面，如果后面没有切面了，再执行最终的目标对象的业务方法。若不执行该方法，则后面的切面，业务bean的方法都不会被执行。其实我们仅使用环绕通知就可以实现前置通知、后置通知、异常通知、最终通知等的效果。proceed方法就是回调执行被代理类中的方法 XML配置方式1.在springMVC配置文件中加入以下配置12345678910&lt;mvc:annotation-driven/&gt; &lt;bean id="sysLogAspect" class="com.wyb.sys.log.SysLogAspect"/&gt; &lt;aop:config&gt; &lt;aop:pointcut id="logPointcut" expression="@annotation(com.wyb.sys.log.SysLogAnnotation)"/&gt; &lt;aop:aspect ref="sysLogAspect"&gt; &lt;aop:around method="around" pointcut-ref="logPointcut"/&gt; &lt;/aop:aspect&gt; &lt;/aop:config&gt; 2.创建切面类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263 public class SysLogAspect &#123; public void logPointCut() &#123; &#125; public Object around(ProceedingJoinPoint point) throws Throwable &#123; long beginTime = System.currentTimeMillis(); //执行方法 Map result = (Map) point.proceed(); //执行时长(毫秒) long time = System.currentTimeMillis() - beginTime; System.out.println(result); //保存日志 saveSysLog(point,result,time); return result; &#125; private void saveSysLog(ProceedingJoinPoint joinPoint,Map result,long time)&#123; try&#123; MethodSignature signature = (MethodSignature) joinPoint.getSignature(); Method method = signature.getMethod(); SysLogAnnotation sysLogAnnotation = method.getAnnotation(SysLogAnnotation.class); if(sysLogAnnotation == null)&#123; return; &#125; SysLog sysLog = new SysLog(); //注解上的值 sysLog.setModule(sysLogAnnotation.module()); sysLog.setMethod(sysLogAnnotation.method()); //请求的方法名 String className = joinPoint.getTarget().getClass().getName(); String methodName = signature.getName(); sysLog.setClassFullName(className + "." + methodName); //设置IP地址 HttpServletRequest request = ((ServletRequestAttributes) RequestContextHolder.getRequestAttributes()).getRequest(); sysLog.setIp(IpUtil.getIpAddr(request)); //请求的参数 Object[] args = joinPoint.getArgs(); sysLog.setParams(JSON.toJSONString(args)); //用户信息 SessionUser sessionUser = ShiroUtils.getSessionUser(); if(sessionUser!=null)&#123; sysLog.setUserId(sessionUser.getId()); sysLog.setUserName(sessionUser.getName()); sysLog.setLoginName(sessionUser.getLoginName()); &#125; sysLog.setTime(time); sysLog.setCreateDate(new Date()); System.out.println(JSON.toJSONString(sysLog)); &#125;catch (Exception e)&#123; &#125; &#125;&#125; 通过上述方式配置,只需要在方法上加入@LogAnnotation注解，就可以实现记录controller操作日志。如果需要记录service层记录，则需要在spring的配置文件中加入配置，另外如果serivce层是实现接口的方式 需要设置使用cglib动态代理方式&lt;aop:aspectj-autoproxy proxy-target-class=&quot;true&quot; /&gt;，因为默认是JDK动态代理。]]></content>
      <categories>
        <category>Spring</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[匿名内部类创建线程的两种方式及区别]]></title>
    <url>%2Fblog%2F2018%2F09%2F21%2F%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F%E5%8F%8A%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[匿名内部类创建线程的两种方式及区别 创建线程的两种方式，继承Thread类，实现Runnable接口。通过匿名类创建线程时一直都是以下两种方式用，也不知道啥区别。 方式一（直接 new Thread的匿名类）： new Thread(){ public void run() { System.out.println("run of thread"); } }.start(); 方式二(Thread类中传入Runnable子类对象)： new Thread(new Runnable() { @Override public void run() { System.out.println("run of runnable"); } }).start(); 区别： 对于 Thread(Runnable target) 而言，只要是重写了Thread自己的run()方法，就不会调用Runnable实现的run()方法。除非在Thread自己的run()方法 加入super.run()执行父类的 run() 方法 如下所示： new Thread(new Runnable() { @Override public void run() { System.out.println("run of runnable"); } }{ public void run() { System.out.println("run of thread"); super.run(); // 加入该句 会执行Runnable 的 run()方法 } }).start(); 原因:Thread run方法的源码 @Override public void run() { if (target != null) { target.run(); } }]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[kaptcha验证码]]></title>
    <url>%2Fblog%2F2018%2F09%2F21%2Fkaptcha%E9%AA%8C%E8%AF%81%E7%A0%81%2F</url>
    <content type="text"><![CDATA[kaptcha验证码 1.Jar包 如果google的不能下载，则使用下面这个，这个是google的副本12345&lt;dependency&gt; &lt;groupId&gt;com.github.penggle&lt;/groupId&gt; &lt;artifactId&gt;kaptcha&lt;/artifactId&gt; &lt;version&gt;2.3.2&lt;/version&gt;&lt;/dependency&gt; 2.配置参数，放入spring配置文件1234567891011121314151617181920212223242526&lt;bean id="producer" class="com.google.code.kaptcha.impl.DefaultKaptcha"&gt; &lt;property name="config"&gt; &lt;bean class="com.google.code.kaptcha.util.Config"&gt; &lt;constructor-arg&gt; &lt;props&gt; &lt;!-- 是否有边框 可选yes 或者 no --&gt; &lt;prop key="kaptcha.border"&gt;yes&lt;/prop&gt; &lt;!-- 边框颜色 --&gt; &lt;prop key="kaptcha.border.color"&gt;105,179,90&lt;/prop&gt; &lt;!-- 验证码文本字符颜色 --&gt; &lt;prop key="kaptcha.textproducer.font.color"&gt;red&lt;/prop&gt; &lt;!-- 验证码文本字符大小 --&gt; &lt;prop key="kaptcha.textproducer.font.size"&gt;50&lt;/prop&gt; &lt;!-- 验证码图片的宽度 默认200 --&gt; &lt;prop key="kaptcha.image.width"&gt;125&lt;/prop&gt; &lt;!-- 验证码图片的高度 默认50 --&gt; &lt;prop key="kaptcha.image.height"&gt;40&lt;/prop&gt; &lt;!-- 验证码文本字符长度 默认为5 --&gt; &lt;prop key="kaptcha.textproducer.char.length"&gt;5&lt;/prop&gt; &lt;!-- 验证码文本字体样式 默认为new Font("Arial", 1, fontSize), new Font("Courier", 1, fontSize) --&gt; &lt;prop key="kaptcha.textproducer.font.names"&gt;宋体,楷体,微软雅黑&lt;/prop&gt; &lt;/props&gt; &lt;/constructor-arg&gt; &lt;/bean&gt; &lt;/property&gt;&lt;/bean&gt; 3.获取验证码，这里需要注入Producer。登录时将 session 中的验证码文本取出来对比即可1234567891011121314151617181920212223242526@Resource private Producer producer; /* * 获取验证码 * */ @GetMapping("/getCaptcha.do") public void getCaptcha(HttpServletResponse response)&#123; try &#123; response.setHeader("Cache-Control", "no-store, no-cache"); response.setContentType("image/jpeg"); //生成文字验证码 String text = producer.createText(); //生成图片验证码 BufferedImage image = producer.createImage(text); //保存到shiro session ShiroUtils.setSessionAttribute(Constants.KAPTCHA_SESSION_KEY, text); ServletOutputStream out = response.getOutputStream(); ImageIO.write(image, "jpg", out); &#125;catch (Exception e)&#123; e.printStackTrace(); &#125; &#125; 4.更多参数详解 Constant 描述 默认值 kaptcha.border 图片边框，合法值：yes , no yes kaptcha.border.color 边框颜色，合法值： r,g,b (and optional alpha) 或者 white,black,blue black kaptcha.border.thickness 边框厚度，合法值：&gt;0 1 kaptcha.image.width 图片宽 200 kaptcha.image.height 图片高 50 kaptcha.producer.impl 图片实现类 com.google.code.kaptcha. impl.DefaultKaptcha kaptcha.textproducer.impl 文本实现类 com.google.code.kaptcha. text.impl.DefaultTextCreator kaptcha.textproducer.char.string 文本集合，验证码值从此集合中获取 abcde2345678gfynmnpwx kaptcha.textproducer.char.length 验证码长度 5 kaptcha.textproducer.font.names 字体 Arial, Courier kaptcha.textproducer.font.size 字体大小 40px kaptcha.textproducer.font.color 字体颜色，合法值：r,g,b 或者 white,black,blue black kaptcha.textproducer.char.space 文字间隔 2 kaptcha.noise.impl 干扰实现类 com.google.code.kaptcha. impl.DefaultNoise kaptcha.noise.color 干扰颜色，合法值：r,g,b 或者 white,black,blue black kaptcha.obscurificator.impl 图片样式：水纹com.google.code.kaptcha. impl.WaterRipple鱼眼com.google.code.kaptcha. impl.FishEyeGimpy阴影com.google.code.kaptcha. impl.ShadowGimpy com.google.code.kaptcha. impl.WaterRipple kaptcha.background.impl 背景实现类 com.google.code.kaptcha. impl.DefaultBackground kaptcha.background.clear.from 背景颜色渐变，开始颜色 light grey kaptcha.background.clear.to 背景颜色渐变，结束颜色 white kaptcha.word.impl 文字渲染器 com.google.code.kaptcha.text. impl.DefaultWordRenderer kaptcha.session.key session key KAPTCHA_SESSION_KEY kaptcha.session.date session date KAPTCHA_SESSION_DATE]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Nginx安装及反向代理配置]]></title>
    <url>%2Fblog%2F2018%2F08%2F31%2FNginx%E5%AE%89%E8%A3%85%E5%8F%8A%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[Nginx安装及反向代理配置 一.安装步骤1.官网找到需要的版本下载连接（稳定版），在linux中使用 wget 下载，然后解压到目录2.cd目录 执行 ./configure 提示 需要安装c/c++的编译器 yum install gcc3.再次执行 ./configure 提示 需要 pcre library yum install pcre 提示 软件包 pcre-8.32-17.el7.x86_64 已安装并且是最新版本 无须任何处理，网上查找 需要 yum install pcre-devel4.再次执行 ./configure 提示 需要 zlib library yum install zlib 提示 软件包 zlib-1.2.7-17.el7.x86_64 已安装并且是最新版本 无须任何处理，同理 yum install zlib-devel5.再次执行 ./configure ,发现 目录下面多了几个文件 ，cat Makefile 可以看到 里面6.make install OK，软件装在了 /usr/local/nginx7.启动nginx ./usr/local/nginx/sbin/nginx 二.设置为开机自启动我们采用源码编译安装的nginx，所以要手动创建nginx.service服务文件，使其开机就能运行。/lib/systemd/system/ 该目录存放开机就能运行的程序。 vi /lib/systemd/system/nginx.service 12345678910111213[Unit] Description=nginx After=network.target [Service] Type=forking ExecStart=/usr/local/nginx/sbin/nginx -c /usr/local/nginx/conf/nginx.confExecReload=/usr/local/nginx/sbin/nginx -s reloadExecStop=/usr/local/nginx/sbin/nginx -s stopPrivateTmp=true[Install] WantedBy=multi-user.target Description:描述服务After:描述服务类别[Service]服务运行参数的设置Type=forking是后台运行的形式ExecStart为服务的具体运行命令ExecReload为重启命令ExecStop为停止命令PrivateTmp=True表示给服务分配独立的临时空间注意：[Service]的启动、重启、停止命令全部要求使用绝对路径[Install]运行级别下服务安装的相关设置，可设置为多用户。 启动nginx服务 systemctl start nginx重启nginx服务 systemctl restart nginx重新加载配置文件 systemctl reload nginx停止nginx服务 systemctl stop nginx设置开机自启动 systemctl enable nginx停止开机自启动 systemctl disable nginx查看服务当前状态 systemctl status nginx 三.nginx.conf反向代理配置使用nginx的反向代理功能实现不同二级域名访问不同项目，配置内容如下所示：12345678910111213141516171819202122232425262728293031 server &#123; listen 80; server_name platform.wyb.com; location / &#123; proxy_pass http://ip:port; &#125; error_page 500 502 503 504 /50x.html; location = /50x.html &#123; root html; &#125; &#125; server &#123; listen 80; server_name demo.wyb.com; location / &#123; proxy_set_header X-Real-IP $remote_addr; proxy_set_header Host $http_host; proxy_pass http://ip:port; &#125; error_page 500 502 503 504 /50x.html; location = /50x.html &#123; root html; &#125; &#125; 四.遇到的问题1.通过外网映射至内部nginx服务器的端口不通，这里牵扯到虚拟机的网络链接方式。 简单了解虚拟机的网络连接方式大致是三种：（1）桥接模式，这种模式下，虚拟机相当于与所在物理机同一IP段的独立计算机，与局域网内的其他计算机是没有区别的。（2）NAT模式，这种模式下，虚拟机与所在的物理机单独组成了一个新的局域网，他们共享接入物理机的IP段。（3）host—only模式，在这种模式下物理机下所属的所有虚拟机共同组成一个局域网，他们与物理机之间是断开的，也就是说物理机和虚拟机之间是无法访问的。 想要访问虚拟机的服务一般是两种方式：（1）将虚拟机的网络连接设置成桥接模式，因为这时候虚拟机相当于所在物理机同一IP段的独立计算机，这时候其他的局域网内的计算机当然可以访问虚拟机内的服务，一般在虚拟机的设置里面找到网络设置，将其设置为桥接模式，借助虚拟机的IP就可以实现访问。（2）将虚拟机的网络连接设置成NAT模式，这么设置局域网内的除了本机外其他计算机是无法访问虚拟机中的服务的，因为局域网内的其他计算机相对于虚拟机和物理机新组的局域网来说属于外网，这时候还需要在物理机中对其进行端口映射，这个与局域网中利用路由器对其中某个IP端口进行映射的原理是一样的，通过这种也可以实现局域网访问虚拟机内的服务。 说明: 一开始我们用的是NAT模式（因为桥接模式需要网管绑定mac,还需要开通上网权限，太麻烦就用NAT模式了），然后映射完成后发现外网是不通的，因为之前做映射的时候遇到过这类问题（本机是没问题的，外网不通，一直找不到原因，结果是防火墙端口没开发，因为是本机所以没开发也能正常），所以这次先直接用了局域网内同事的电脑看能不能访问，结果显而易见不能，所以先解决内网不通的问题，这里就涉及到前面的虚拟机的网络链接方式，于是乎做映射呗。做完映射局域网内的机器就可以访问我的虚拟机了，nginx转发内网也没问题。外网依然不能访问，中间断断续续搞了两天，很多方法都试过，中间也把nginx的所在的虚拟机的网络设置为了桥接等等。我外网端口直接映射 linux 所在虚拟机是通的，所以linux这台机器是可以连接外网的（之前做映射的时候，因为网管那里有限制，导致映射的那台机器不能连外网，所以不通）,唯独就是映射给nginx那个端口不能转发，这里因为所有东西都是在我本机上的没所以很麻烦，我本机是都没问题的，而且我自己测都是通的，所以需要别的机器（不是我们公司的网络）帮忙测试端口通不通，最后锁定 映射到 nginx 的哪个端口不通，很纠结，开始以为哪里配置错了，然后改啊改，始终不行，最后瞎改想着把外网的端口改下，原来用的8080 改成 9080 ，我擦，OK了。这个就很郁闷，最早用的是外网 80 端口，一直不通，后来知道是因为运营商封了，公司也没申请开通，所以就换个 8080 试一试，想着这个端口应该没封吧，结果断断续续折腾了 1天多 还是因为这个端口的问题。这里面环境因素占了很大一部分原因，本机搭建环境本机测，防火墙不关也不会有问题啊，但是局域网和外网就肯定有问题啊，以后搭建环境 首先考虑防火墙，这里因为防火墙的原因也没少折腾。 2.nginx error.log 出现[error] 2669#0: *6 open() “/usr/local/nginx/html/favicon.ico” failed (2: No such file or directory), client: 192.168.0.1, server: 122.227.141.54, request: “GET /favicon.ico HTTP/1.1”, host: “122.227.141.54:8080”, referrer: “http://122.227.141.54:8080/&quot; 解决方法：关闭 favicon.ico 的log1234location = /favicon.ico &#123; log_not_found off; access_log off;&#125; 3.nginx 启动/重启、重新加载报错 error.log 出现[error] 2591#0: invalid PID number “” in “/usr/local/nginx/logs/nginx.pid”使用nginx -c的参数指定nginx.conf文件的位置[root@localhost nginx]# /usr/local/nginx/sbin/nginx -c /usr/local/nginx/conf/nginx.conf 4.网页出现 504 gateway timeout 连接超时nginx erro.log 出现[error] 6324#0: *69 upstream timed out (110: Connection timed out) while connecting to upstream可以在 location 内加入下面的配置，将链接时间调大12345678proxy_connect_timeout 300s; #nginx跟后端服务器连接超时时间(代理连接超时)proxy_read_timeout 300s; #连接成功后，后端服务器响应时间(代理接收超时)proxy_send_timeout 300s;proxy_buffer_size 64k; #设置代理服务器（nginx）保存用户头信息的缓冲区大小proxy_buffers 4 32k; #proxy_buffers缓冲区，网页平均在32k以下的话，这样设置proxy_busy_buffers_size 64k; #高负荷下缓冲大小（proxy_buffers*2）proxy_temp_file_write_size 64k; #设定缓存文件夹大小，大于这个值，将从upstream服务器传递请求，而不缓冲到磁盘proxy_ignore_client_abort on; #不允许代理端主动关闭连接 5.nginx默认只能上传1M的文件，如果上传文件比较大可以加入以下配置1234client_max_body_size 50m; #缓冲区代理缓冲用户端请求的最大字节数,可以理解为保存到本地再传给用户client_body_buffer_size 256k;client_header_timeout 3m;client_body_timeout 3m; 可以在http{ }中设置,也可以在server{ }中设置,还可以在location{ }中设置三者到区别是：http{}中控制所有nginx收到的请求，server{}中控制该server收到的请求，location{}中控制匹配了location 路由规则的请求。 6.nginx 302重定向问题因为我们是用的端口映射至nginx的，所以导致nginx自动添加内网端口。在 location{ proxy_set_header Host $host } 加入外网的端口号即可。如下:1234proxy_set_header Host $host:9080; proxy_set_header X-Real-IP $remote_addr; proxy_set_header REMOTE-HOST $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; 五.错误信息说明 错误信息 说明 upstream prematurely closed connection 请求url的时候出现的异常，是由于upstream还未返回应答给用户时用户断掉连接造成的，对系统没有影响，可以忽略 recv() failed (104: Connection reset by peer) （1）服务器的并发连接数超过了其承载量，服务器会将其中一些连接Down掉（2）客户关掉了浏览器，而服务器还在给客户端发送数据 （3）浏览器端按了Stop (111: Connection refused) while connecting to upstream 用户在连接时，若遇到后端upstream挂掉或者不通，会收到该错误 (111: Connection refused) while reading response header from upstream 用户在连接成功后读取数据时，若遇到后端upstream挂掉或者不通，会收到该错误 (111: Connection refused) while sending request to upstream Nginx和upstream连接成功后发送数据时，若遇到后端upstream挂掉或者不通，会收到该错误 (110: Connection timed out) while connecting to upstream nginx连接后面的upstream时超时 (110: Connection timed out) while reading upstream nginx读取来自upstream的响应时超时 (110: Connection timed out) while reading response header from upstream nginx读取来自upstream的响应头时超时 (110: Connection timed out) while reading upstream nginx读取来自upstream的响应时超时 (104: Connection reset by peer) while connecting to upstream upstream发送了RST，将连接重置 upstream sent invalid header while reading response header from upstream upstream发送的响应头无效 upstream sent no valid HTTP/1.0 header while reading response header from upstream upstream发送的响应头无效 client intended to send too large body 用于设置允许接受的客户端请求内容的最大值，默认值是1M，client发送的body超过了设置值 reopening logs 用户发送kill -USR1命令 gracefully shutting down 用户发送kill -WINCH命令 no servers are inside upstream upstream下未配置server no live upstreams while connecting to upstream upstream下的server全都挂了 SSL_do_handshake() failed SSL握手失败 ngx_slab_alloc() failed: no memory in SSL session shared cache ssl_session_cache大小不够等原因造成 could not add new SSL session to the session cache while SSL handshaking ssl_session_cache大小不够等原因造成]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Linux安装Java、Tomcat]]></title>
    <url>%2Fblog%2F2018%2F08%2F31%2FLinux%E5%AE%89%E8%A3%85Java%E5%92%8CTomcat%2F</url>
    <content type="text"><![CDATA[Linux安装Java、Tomcat(未整理、排版) ####linux 小技巧1.关键/敏感操作 使用别名在 Red Hat 企业版 Linux 中，如果你使用 root 帐户，则默认设置这些别名。如果你还要为普通用户帐户设置这些别名，只需将这两行放入家目录下名为 .bashrc 的文件中（这些也适用于 sudo ）：alias mv=’mv -i’alias rm=’rm -i’ 2.关键/敏感用户（root）使用鲜艳的颜色如果将以下内容放入 root 的家目录中的 .bashrc 文件中，你将看到一个黑色背景上的红色的 root 提示符，清楚地表明你（或其他任何人）应该谨慎行事。export PS1=”[$(tput bold)$(tput setab 0)$(tput setaf 1)]\u@\h:\w # [$(tput sgr0)]“ 3.以空格开头的命令不保存到历史记录列表设置你可能知道在 Bash 中你按向上的箭头时能看见和重新使用你之前所有（好吧，大多数）的命令。这是因为这些命令已经保存到了你家目录下的名为 .bash_history 的文件中。这个历史文件附带了一组有用的设置和命令。将以下内容添加到 .bashrc，那么任何以空格开头的命令都不会保存到历史记录列表中：HISTCONTROL=ignorespace如果你需要以明文形式将密码传递给一个命令，这就非常有用。 4.如果你不希望经常执行的命令充斥在历史记录中，请使用：HISTCONTROL=ignorespace:erasedups这样，每次使用一个命令时，都会从历史记录文件中删除之前出现的所有相同命令，并且只将最后一次调用保存到历史记录列表中。使用：HISTTIMEFORMAT=”%F %T “ 将在历史记录文件中在所有的条目前面添加上时间戳。 java以及环境安装很多linux系统中默认都装了openjdk1.查看linux中自带的java1234567891011121314151617yum list installed | grep javaorrpm -qa|grep jdkor[root@localhost ~]# which java/usr/bin/java[root@localhost ~]# ls -lrt /usr/bin/javalrwxrwxrwx. 1 root root 22 Aug 17 15:12 /usr/bin/java -&gt; /etc/alternatives/java[root@localhost ~]# ls -lrt /etc/alternatives/javalrwxrwxrwx. 1 root root 46 Aug 17 15:12 /etc/alternatives/java -&gt; /usr/lib/jvm/jre-1.7.0-openjdk.x86_64/bin/java[root@localhost ~]# [root@localhost ~]# cd /usr/lib/jvm[root@localhost jvm]# ls 2.卸载自带的openJDK12345yum -y remove R-java R-java-devel java-1.7.0-openjdk.x86_64 java-1.7.0-openjdk-devel.x86_64 java-1.8.0-openjdk.x86_64 java-1.8.0-openjdk-headless.x86_64 tzdata-java.noarchorrpm -e --nodeps java-1.8.0-openjdk-1.8.0.102-4.b14.el7.x86_64 3.解压jdk文件并且放置在/usr/local/java/下面1234cd /usr/local #进入该目录mkdir java #新建java文件夹cd java #进入java目录tar -zxvf /xx/xxx/jdk-8u181-linux-x64.tar.gz #将jdk的压缩文件解压到该目录下 4.配置环境变量123456789101112131415161718192021vim /etc/profile #编辑该文件，将以下信息加入文件底部export JAVA_HOME=/usr/local/java/jdk1.8.0_181export PATH=$JAVA_HOME/bin:$PATH export CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar source /etc/profile #重新加载该文件，使其生效5.设置默认的java(这一步设不设都行)``` linuxupdate-alternatives --remove-all &quot;java&quot;update-alternatives --remove-all &quot;javac&quot;update-alternatives --remove-all &quot;javaws&quot;update-alternatives --install &quot;/usr/bin/java&quot; &quot;java&quot; &quot;/usr/local/java/jdk1.8.0_181/bin/java&quot; 1update-alternatives --install &quot;/usr/bin/javac&quot; &quot;javac&quot; &quot;/usr/local/java/jdk1.8.0_181/bin/javac&quot; 1update-alternatives --install &quot;/usr/bin/javaws&quot; &quot;javaws&quot; &quot;/usr/local/java/jdk1.8.0_181/bin/javaws&quot; 1update-alternatives --set java /usr/local/java/jdk1.8.0_181/bin/javaupdate-alternatives --set javac /usr/local/java/jdk1.8.0_181/bin/javacupdate-alternatives --set javaws /usr/local/java/jdk1.8.0_181/bin/javaws ####tomcate安装 Centos7使用firewalld代替了原来的iptables一 firewalld1.firewalld的基本使用启动： systemctl start firewalld关闭： systemctl stop firewalld查看状态： systemctl status firewalld开机禁用 ： systemctl disable firewalld开机启用 ： systemctl enable firewalld 2.systemctl是CentOS7的服务管理工具中主要的工具，它融合之前service和chkconfig的功能于一体。启动一个服务：systemctl start firewalld.service关闭一个服务：systemctl stop firewalld.service重启一个服务：systemctl restart firewalld.service显示一个服务的状态：systemctl status firewalld.service在开机时启用一个服务：systemctl enable firewalld.service在开机时禁用一个服务：systemctl disable firewalld.service查看服务是否开机启动：systemctl is-enabled firewalld.service查看已启动的服务列表：systemctl list-unit-files|grep enabled查看启动失败的服务列表：systemctl –failed 3.配置firewalld-cmd查看版本： firewall-cmd –version查看帮助： firewall-cmd –help显示状态： firewall-cmd –state查看所有打开的端口： firewall-cmd –zone=public –list-ports更新防火墙规则： firewall-cmd –reload查看区域信息: firewall-cmd –get-active-zones查看指定接口所属区域： firewall-cmd –get-zone-of-interface=eth0拒绝所有包：firewall-cmd –panic-on取消拒绝状态： firewall-cmd –panic-off查看是否拒绝： firewall-cmd –query-panic 开启一个端口firewall-cmd –zone=public –add-port=8080/tcp –permanent （–permanent永久生效，没有此参数重启后失效）重新载入firewall-cmd –reload查看firewall-cmd –zone=public –query-port=80/tcp删除firewall-cmd –zone=public –remove-port=80/tcp –permanent firewalld默认配置文件有两个：/usr/lib/firewalld/ （系统配置，请勿编辑 尽量不修改）和 /etc/firewalld/ （用户配置地址） firewall-cmd –list-services –查看当前打开了哪些服务 firewall-cmd –get-services –查看可以打开的服务有哪些,每个服务对应/usr/lib/firewalld/services下面一个xml文件,所以也可以 ls /etc/firewalld/services/ 查看 firewall-cmd –add-service=http –添加一个服务到firewalld http换成想要开放的service 这样添加的service当前立刻生效，但系统下次启动就失效。 firewall-cmd –permanent –add-service=http – 加上 –permanent 永久有效 zone概念：硬件防火墙默认一般有三个区，firewalld引入这一概念系统默认存在以下区域（根据文档自己理解，如果有误请指正）：drop：默认丢弃所有包block：拒绝所有外部连接，允许内部发起的连接public：指定外部连接可以进入external：这个不太明白，功能上和上面相同，允许指定的外部连接dmz：和硬件防火墙一样，受限制的公共连接可以进入work：工作区，概念和workgoup一样，也是指定的外部连接允许home：类似家庭组internal：信任所有连接 Centos7官方文档 二 iptables 1.停止并屏蔽firewalld服务systemctl stop firewalldsystemctl mask firewalld 2.安装iptables-services软件包yum install iptables-services 3.在引导时启用iptables服务 开机启动systemctl enable iptables 4.启动iptables服务systemctl start iptablesservice iptables status –查看iptables状态 5.保存防火墙规则service iptables save vim /etc/sysconfig/iptables –添加规则 管理iptables服务 systemctl [stop|start|restart] iptables 开机后网络不能用systemctl –failed –查看启动失败的服务 UNIT LOAD ACTIVE SUB DESCRIPTION● kdump.service loaded failed failed Crash recovery kernel arming● network.service loaded failed failed LSB: Bring up/down networking● rngd.service loaded failed failed Hardware RNG Entropy Gatherer Daemon network.service启动失败，手动重启 systemctl start network Job for network.service failed because the control process exited with error code. See “systemctl status network.service” and “journalctl -xe” for details 执行 systemctl status network.service ● network.service - LSB: Bring up/down networking Loaded: loaded (/etc/rc.d/init.d/network; bad; vendor preset: disabled) Active: failed (Result: exit-code) since 三 2018-08-22 09:04:58 CST; 5min ago Docs: man:systemd-sysv-generator(8) Process: 2898 ExecStart=/etc/rc.d/init.d/network start (code=exited, status=1/FAILURE) 8月 22 09:04:58 localhost.localdomain network[2898]: RTNETLINK answers: File exists8月 22 09:04:58 localhost.localdomain network[2898]: RTNETLINK answers: File exists8月 22 09:04:58 localhost.localdomain network[2898]: RTNETLINK answers: File exists8月 22 09:04:58 localhost.localdomain network[2898]: RTNETLINK answers: File exists8月 22 09:04:58 localhost.localdomain network[2898]: RTNETLINK answers: File exists8月 22 09:04:58 localhost.localdomain network[2898]: RTNETLINK answers: File exists8月 22 09:04:58 localhost.localdomain systemd[1]: network.service: control process exited, code=exited status=18月 22 09:04:58 localhost.localdomain systemd[1]: Failed to start LSB: Bring up/down networking.8月 22 09:04:58 localhost.localdomain systemd[1]: Unit network.service entered failed state.8月 22 09:04:58 localhost.localdomain systemd[1]: network.service failed. ● network.service - LSB: Bring up/down networking Loaded: loaded (/etc/rc.d/init.d/network; bad; vendor preset: disabled) Active: failed (Result: exit-code) since 三 2018-08-22 09:57:41 CST; 27s ago Docs: man:systemd-sysv-generator(8) Process: 3514 ExecStop=/etc/rc.d/init.d/network stop (code=exited, status=0/SUCCESS) Process: 3644 ExecStart=/etc/rc.d/init.d/network start (code=exited, status=1/FAILURE) 8月 22 09:57:41 localhost.localdomain systemd[1]: Starting LSB: Bring up/down networking…8月 22 09:57:41 localhost.localdomain network[3644]: 正在打开环回接口： [ 确定 ]8月 22 09:57:41 localhost.localdomain network[3644]: 正在打开接口 ens33： 错误：激活连接失败：No suitable device found for this connection.8月 22 09:57:41 localhost.localdomain network[3644]: [失败]8月 22 09:57:41 localhost.localdomain systemd[1]: network.service: control process exited, code=exited status=18月 22 09:57:41 localhost.localdomain systemd[1]: Failed to start LSB: Bring up/down networking.8月 22 09:57:41 localhost.localdomain systemd[1]: Unit network.service entered failed state.8月 22 09:57:41 localhost.localdomain systemd[1]: network.service failed. 以上原因经几番折腾排查（MAC），是 VMware DHCP Service 和 VMware NAT Service 未启动的原因 编辑–&gt;虚拟网络编辑器–&gt;还原默认设置，重启OK。 [ERROR] COMPILATION ERROR :[INFO] ————————————————————-[ERROR] /home/platform/platform/src/main/java/com/jwei/rad/action/WordbookAction.java:[29,52] -source 1.5 中不支持 diamond 运算符 (请使用 -source 7 或更高版本以启用 diamond 运算符)[ERROR] /home/platform/platform/src/main/java/com/jwei/sys/action/RoleAction.java:[29,52] -source 1.5 中不支持 diamond 运算符 (请使用 -source 7 或更高版本以启用 diamond 运算符)[ERROR] /home/platform/platform/src/main/java/com/jwei/sys/action/UserAction.java:[59,52] -source 1.5 中不支持 diamond 运算符 (请使用 -source 7 或更高版本以启用 diamond 运算符)[ERROR] /home/platform/platform/src/main/java/com/jwei/sys/action/MenuAction.java:[29,52] -source 1.5 中不支持 diamond 运算符 (请使用 -source 7 或更高版本以启用 diamond 运算符)[ERROR] /home/platform/platform/src/main/java/com/jwei/task/service/Impl/K3ToAoTingImpl.java:[240,41] -source 1.5 中不支持 diamond 运算符 (请使用 -source 7 或更高版本以启用 diamond 运算符)[ERROR] /home/platform/platform/src/main/java/com/jwei/sys/action/RoleMenuAction.java:[30,52] -source 1.5 中不支持 diamond 运算符 (请使用 -source 7 或更高版本以启用 diamond 运算符)[ERROR] /home/platform/platform/src/main/java/com/jwei/sys/action/DeptAction.java:[29,52] -source 1.5 中不支持 diamond 运算符 (请使用 -source 7 或更高版本以启用 diamond 运算符)[ERROR] /home/platform/platform/src/main/java/com/jwei/api/ProductAPIAction.java:[37,52] -source 1.5 中不支持 diamond 运算符 (请使用 -source 7 或更高版本以启用 diamond 运算符)[ERROR] /home/platform/platform/src/main/java/com/jwei/sys/action/UserRoleAction.java:[28,52] -source 1.5 中不支持 diamond 运算符 (请使用 -source 7 或更高版本以启用 diamond 运算符)[ERROR] /home/platform/platform/src/main/java/com/jwei/api/MailTestAction.java:[25,52] -source 1.5 中不支持 diamond 运算符 (请使用 -source 7 或更高版本以启用 diamond 运算符)[ERROR] /home/platform/platform/src/main/java/com/jwei/sys/action/FileAction.java:[34,52] -source 1.5 中不支持 diamond 运算符 (请使用 -source 7 或更高版本以启用 diamond 运算符)[ERROR] /home/platform/platform/src/main/java/com/jwei/utils/MemoryTest.java:[25,29] -source 1.5 中不支持文字中存在下划线 (请使用 -source 7 或更高版本以允许文字中存在下划线)[ERROR] /home/platform/platform/src/main/java/com/jwei/rad/service/impl/ProductSVImpl.java:[96,61] -source 1.5 中不支持 diamond 运算符 (请使用 -source 7 或更高版本以启用 diamond 运算符)[ERROR] /home/platform/platform/src/main/java/com/jwei/sys/action/AdminAction.java:[36,52] -source 1.5 中不支持 diamond 运算符 (请使用 -source 7 或更高版本以启用 diamond 运算符)[ERROR] /home/platform/platform/src/main/java/com/jwei/rad/action/ProductAction.java:[35,52] -source 1.5 中不支持 diamond 运算符 (请使用 -source 7 或更高版本以启用 diamond 运算符)[ERROR] /home/platform/platform/src/main/java/com/jwei/hr/action/EmployeeAction.java:[34,52] -source 1.5 中不支持 diamond 运算符 (请使用 -source 7 或更高版本以启用 diamond 运算符)[ERROR] /home/platform/platform/src/main/java/com/jwei/utils/ListTest.java:[24,39] -source 1.5 中不支持 diamond 运算符 (请使用 -source 7 或更高版本以启用 diamond 运算符) The -source argument for the Java compiler. NOTE: Since 3.8.0 the default value has changed from 1.5 to 1.6Type: java.lang.StringSince: 2.0Required: NoUser Property: maven.compiler.sourceDefault: 1.6 [maven官网说明]http://maven.apache.org/plugins/maven-compiler-plugin/compile-mojo.html 所以在 pom.xml 中加入 &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt;如下: &lt;spring.version&gt;4.3.14.RELEASE&lt;/spring.version&gt; &lt;shiro.version&gt;1.3.2&lt;/shiro.version&gt; 1.3.1 &lt;mybatis.version&gt;3.4.1&lt;/mybatis.version&gt; 1.2.7 &lt;mail.version&gt;1.6.1&lt;/mail.version&gt; &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; 将 VMware 虚拟机 设置固定的IP 打开虚拟机后，在编辑&gt;模拟网络编辑器&gt;选择 Vmnet8 Net模式 ，在子网IP（I）栏 随意设置子网IP（192.168.18.0），子网掩码（M）栏一般不修改（255.255.255.0）&gt;点击NAT设置，网关IP（G）栏设置（192.168.18.2），后面修改静态IP会用到设置的IP地址、子网掩码、和网关。 然后进入到虚拟机中，如果装了图形界面的话直接在网络设置里将地址设置为固定IP即可。 命令行如下： 查看网卡配置（ens33是虚拟机网卡名称）sudo cat /etc/sysconfig/network-scripts/ifcfg-ens33 HWADDR=00:50:56:2C:65:E7MACADDR=00:50:56:2C:65:E7TYPE=EthernetPROXY_METHOD=noneBROWSER_ONLY=noBOOTPROTO=dhcpDEFROUTE=yesIPV4_FAILURE_FATAL=noIPV6INIT=yesIPV6_AUTOCONF=yesIPV6_DEFROUTE=yesIPV6_FAILURE_FATAL=noIPV6_ADDR_GEN_MODE=stable-privacyNAME=ens33UUID=e1bb43c7-f2a6-3bb4-b1b4-21111e95ddceDEVICE=ens33ONBOOT=yesZONE= 需要加入如下信息bootproto=static –none：无（不指定） static：静态IP地址 dhcp：获得动态IP地址IPADDR=192.168.18.128 –IP地址NETMASK=255.255.255.0 –子网掩码GATEWAY=192.168.18.2 –网关DNS1=192.168.18.2 –如果不能链接外网，则把DNS设置加上 HWADDR=00:50:56:2C:65:E7MACADDR=00:50:56:2C:65:E7TYPE=EthernetPROXY_METHOD=noneBROWSER_ONLY=noBOOTPROTO=noneDEFROUTE=yesIPV4_FAILURE_FATAL=noIPV6INIT=yesIPV6_AUTOCONF=yesIPV6_DEFROUTE=yesIPV6_FAILURE_FATAL=noIPV6_ADDR_GEN_MODE=stable-privacyNAME=ens33UUID=e1bb43c7-f2a6-3bb4-b1b4-21111e95ddceONBOOT=yesPEERDNS=no echo “将platform-1.0-SNAPSHOT.war 移动至 tomcat webapps目录并命名为 ROOT.war”mv /home/platform/platform/target/platform-1.0-SNAPSHOT.war /usr/local/java/apache-tomcat-1/webapps/ROOT.war echo “停止Tomcat”/usr/local/java/apache-tomcat-1/bin/shutdown.sh echo “启动Tomcat”/usr/local/java/apache-tomcat-1/bin/startup.sh echo “输出启动日志”tail -f /usr/local/java/apache-tomcat-1/logs/catalina.out echo “catalina.sh run方式启动”/usr/local/java/apache-tomcat-1/bin/catalina.sh run 显示主机名信息 hostname hostnamectl status（显示更全的信息） 设置主机名 hostnamectl set-hostname centos7（即时生效，直接写入配置文件） 删除文件/etc/hostname， 恢复主机名localhost.localdomain CentOS 7网络配置工具nmcli 修改IP地址等属性 nmcli connection modify eth2 autoconnect nonmcli connection modify eth2 ipv4.method autonmcli connection modify eth2 +ipv4.addresses 192.168.111.122/24nmcli connection modify eth2 +ipv4.dns 8.8.8.8 DNS设置，存放在/etc/resolv.conf文件中PEERDNS=no 表示当IP通过dhcp自动获取时， dns仍是手动设置，不自动获取。等价于下面命令：nmcli con mod “system eth0” ipv4.ignore-auto-dns yes 修改配置文件执行生效 systemctl restart network nmcli connection reload 网络接口的启用与停用： nmcli connection down eth0 nmcli connection up eth0 显示所有包括不活动连接 nmcli connection show 显示所有活动连接 nmcli connection show –active 显示网络连接配置 nmcli connection show eth0 显示设备状态 nmcli device status 显示网络接口属性 nmcli device show eth0 创建新连接default， IP自动通过dhcp获取 nmcli connection add con-name eth0 type Ethernet ifname eth0 创建新连接static ，指定静态IP，不自动连接 nmcli connection add con-name eth4 ifname eth4 autoconnect no type Ethernet ipv4.address 172.25.12.10/24 ipv4.gateway 172.25.12.254]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Log4j分别打印不同级别的日志文件]]></title>
    <url>%2Fblog%2F2018%2F07%2F12%2FLog4j%E5%88%86%E5%88%AB%E6%89%93%E5%8D%B0%E4%B8%8D%E5%90%8C%E7%BA%A7%E5%88%AB%E7%9A%84%E6%97%A5%E5%BF%97%E6%96%87%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[Log4j分别打印console,info,warn,error,show_sql日志文件 log4j.rootLogger=INFO,console,info,warn,error #输出到控制台log4j.appender.console=org.apache.log4j.ConsoleAppenderlog4j.appender.console.Target=System.outlog4j.appender.console.Threshold=DEBUGlog4j.appender.console.layout=org.apache.log4j.PatternLayoutlog4j.appender.console.layout.ConversionPattern=%d %p [%c] - &lt;%m&gt;%n #log4j.appender.stdout.layout.ConversionPattern=[%p][%d{yyyy-MM-dd HH:mm:ss}] %l %m %n #INFO日志log4j.appender.info=org.apache.log4j.DailyRollingFileAppenderlog4j.appender.info.File = ${catalina.base}/logs/info.loglog4j.appender.info.datePattern=’.’yyyy-MM-ddlog4j.appender.info.append=truelog4j.appender.info.Threshold=INFOlog4j.appender.info.layout=org.apache.log4j.PatternLayoutlog4j.appender.info.layout.ConversionPattern=%d{yyyy-MM-dd HH:mm:ss} %p [%l] %m %n #WARN日志log4j.appender.warn=org.apache.log4j.DailyRollingFileAppenderlog4j.appender.warn.File = ${catalina.base}/logs/warn.loglog4j.appender.warn.datePattern=’.’yyyy-MM-ddlog4j.appender.warn.append=truelog4j.appender.warn.Threshold=WARNlog4j.appender.warn.layout=org.apache.log4j.PatternLayoutlog4j.appender.warn.layout.ConversionPattern=%d{yyyy-MM-dd HH:mm:ss} %p [%l] %m %n #ERROR日志log4j.appender.error=org.apache.log4j.DailyRollingFileAppenderlog4j.appender.error.File = ${catalina.base}/logs/error.loglog4j.appender.error.datePattern=’.’yyyy-MM-ddlog4j.appender.error.append=truelog4j.appender.error.Threshold=ERRORlog4j.appender.error.layout=org.apache.log4j.PatternLayoutlog4j.appender.error.layout.ConversionPattern=%d{yyyy-MM-dd HH:mm:ss} %p [%l] %m %n SQL日志log4j.appender.showsql=org.apache.log4j.DailyRollingFileAppenderlog4j.appender.showsql.File = ${catalina.base}/logs/slow_sql.loglog4j.appender.showsql.datePattern=’.’yyyy-MM-ddlog4j.appender.showsql.append=truelog4j.appender.showsql.layout=org.apache.log4j.PatternLayoutlog4j.appender.showsql.layout.ConversionPattern=%d{yyyy-MM-dd HH:mm:ss} %p [%c] %m %n #druid 日志 #log4j.logger.druid.sql.Statement=DEBUG,showsql #log4j.logger.druid.sql.DataSource=warn,showsql #log4j.logger.druid.sql.Connection=warn,showsql #log4j.logger.druid.sql.ResultSet=warn,showsql #mybatis显示SQL语句日志配置log4j.logger.com.jwei.sys.dao=DEBUG,showsqllog4j.logger.com.jwei.rad.dao=DEBUG,showsql #log4j.logger.java.sql.Connection=DEBUG #log4j.logger.java.sql.Statement=DEBUG #log4j.logger.java.sql.PreparedStatement=DEBUG %c 输出日志信息所属的类的全名%d 输出日志时间点的日期或时间，默认格式为ISO8601，也可以在其后指定格式，比如：%d{yyy-MM-dd HH:mm:ss}，输出类似：2018-08-02 16:54:04%f 输出日志信息所属的类的类名%l 输出日志事件的发生位置，即输出日志信息的语句处于它所在的类的第几行%m 输出代码中指定的信息，如log(message)中的message%n 输出一个回车换行符，Windows平台为“rn”，Unix平台为“n”%p 输出优先级，即DEBUG，INFO，WARN，ERROR，FATAL。如果是调用debug()输出的，则为DEBUG，依此类推%r 输出自应用启动到输出该日志信息所耗费的毫秒数%t 输出产生该日志事件的线程名]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[浅层、深层拷贝]]></title>
    <url>%2Fblog%2F2018%2F06%2F22%2F%E6%B5%85%E5%B1%82%E3%80%81%E6%B7%B1%E5%B1%82%E6%8B%B7%E8%B4%9D%2F</url>
    <content type="text"><![CDATA[浅层、深层拷贝 浅层拷贝：两个变量指示内存中的地址是不一样的，但是变量中的元素指向同一个元素。深层拷贝: 不仅仅变量指示的内存地址不一样，而且变量中的各个元素所指地址也是不一样的。 浅拷贝: 只是对源list的元素进行拷贝，拷贝的只是引用。拷贝后两个list的元素（引用）不同，但是引用所指向的对象是一样的。即是两个list的每个元素指向的还是通一内存。深拷贝: 不光拷贝的是src的元素（引用），src内每个元素的所指向的对象都进行一次 拷贝。即是两个list的每个元素所指向的不是同一内存。 浅层拷贝ArrayList.clone()remove不修改集合中的元素，只是在List内部的数组中移除了指向元素的地址 深层拷贝12345678// 方式一List&lt;SysRoleMenu&gt; copyList = new ArrayList(Arrays.asList(new SysRoleMenu[list.size])); 指定目标copyList的大小Collections.copy(copyList, list);// 方式二List&lt;SysRoleMenu&gt; copyList = new ArrayList&lt;&gt;(); Collections.addAll(copyList, new SysRoleMenu[list.size()]);Collections.copy(copyList, list);]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[REST风格的接口设计]]></title>
    <url>%2Fblog%2F2018%2F06%2F22%2FREST%E9%A3%8E%E6%A0%BC%E7%9A%84%E6%8E%A5%E5%8F%A3%E8%AE%BE%E8%AE%A1%2F</url>
    <content type="text"><![CDATA[REST风格的接口设计 简单来讲就是：URL定位资源，用HTTP（GET，POST，PUT，PATCH，DELETE）描述操作。 例如我们对用户进行操作时，根据操作的方式不同定义了以下的这些接口，这些接口中的动名词通常对应后台的某个函数。 增加用户 /user/createUser删除用户 /user/deleteUser修改用户 /user/modifyUser查找用户 /user/getUser REST风格的接口是不应该出现get/create/modify/delete这些动词的,可以通过HTTP的几个请求类型来区分不同的业务。GET，POST，PUT，PATCH，DELETE，这几个方法都可以与对数据的 CRUD 操作对应起来。 下面我们对users设计REST风格的接口： 增加用户 /sys/users 接口类型：POST删除用户 /sys/users 接口类型：DELETE修改用户 /sys/users 接口类型：PUT/PATCH查找用户 /sys/users 接口类型：GET REST的更多详细规范]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Spring Boot问题记录]]></title>
    <url>%2Fblog%2F2018%2F06%2F22%2FSpring%20Boot%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[Spring Boot 问题记录 1.spring boot项目只有src目录，没有webapp目录，会将静态访问(html/图片等)映射到其自动配置的静态目录，如下:12345/static/public/resources/META-INF/resources优先级顺序为：/META-INF/resources &gt; resources &gt; static &gt; public 2.No SecurityManager accessible to the calling code, either bound to the org.apache.shiro.util.ThreadContext or as a vm static singleton. This is an invalid application configuration 忘了加载shiro配置文件，原来在搞访问静态资源的时候，老是重定向，就把shiro去掉了，搞好之后忘了加回来。 3.加入shiro后，访问login页面总是出现重定向错误，原因是我们把静态资源全都放在了static下,在shiro配置过滤链的时候虽加入了/static/** = anon，但此配置是无用的，因为对于shiro来讲，他不知道static目录的存在，前端页面访问的URL是login.html,但是过滤链中并没有login.html的相关设置，所以会匹配到/**=authc上，然后调用设置的&lt;property name=&quot;loginUrl&quot; value=&quot;/login.html&quot;/&gt;让用户登录，此时就陷入了循环，就一直重定向了。我们把/**=authc 去掉，发现访问login.html是正常的，这是因为此时没有相关拦截，过了这层后，springBoot会将静态访问(html/图片等)映射到其自动配置的静态目录，见问题1。所以此时的static文件夹相当于webapp。那我们如果不想把static文件夹下面的所有都在过滤链里写的话，可以通过修改application.properties添加spring.mvc.static-path-pattern=/static/**，这个时候url会变成localhost:8080/staitc/login.html 且loginUrl，successUrl，unauthorizedUrl都需要加上/static/xxx。这时候需要在/static/** = anon前面加上index.html=authc。以下是二种方式的汇总方式一：12345678910111213&lt;!-- 默认的登陆访问url --&gt;&lt;property name="loginUrl" value="/login.html"/&gt;&lt;!-- 登陆成功后跳转的url --&gt;&lt;property name="successUrl" value="/index.html"/&gt;&lt;!-- 没有权限跳转的url --&gt;&lt;property name="unauthorizedUrl" value="/unauth.html"/&gt;过滤链：/login.html = anon/css/** = anon/lib/** = anon/img/** = anonurl ：localhost:8080/login.html 方式二：1234567891011121314application.propertiesspring.mvc.static-path-pattern=/static/**&lt;!-- 默认的登陆访问url --&gt;&lt;property name="loginUrl" value="/login.html"/&gt;&lt;!-- 登陆成功后跳转的url --&gt;&lt;property name="successUrl" value="/index.html"/&gt;&lt;!-- 没有权限跳转的url --&gt;&lt;property name="unauthorizedUrl" value="/unauth.html"/&gt;过滤链：/index.html=authc/static/** = anonurl ：localhost:8080/static/login.html 4.即使配置了相关URL放开也会被拦截的原因 shiro 配置/logout = logout的时候，只要在xml中声明了bean为LogoutFilter，登录的时候就被拦截，控制台输出信息是Mapping filter: &#39;logoutFilter&#39; to: [/*]，输出信息如下：1234567[INFO ] 2018-06-30 16:32:32,445 org.springframework.boot.web.servlet.ServletRegistrationBean - Servlet dispatcherServlet mapped to [/][INFO ] 2018-06-30 16:32:32,457 org.springframework.boot.web.servlet.FilterRegistrationBean - Mapping filter: 'characterEncodingFilter' to: [/*][INFO ] 2018-06-30 16:32:32,458 org.springframework.boot.web.servlet.FilterRegistrationBean - Mapping filter: 'hiddenHttpMethodFilter' to: [/*][INFO ] 2018-06-30 16:32:32,459 org.springframework.boot.web.servlet.FilterRegistrationBean - Mapping filter: 'httpPutFormContentFilter' to: [/*][INFO ] 2018-06-30 16:32:32,459 org.springframework.boot.web.servlet.FilterRegistrationBean - Mapping filter: 'requestContextFilter' to: [/*][INFO ] 2018-06-30 16:32:32,459 org.springframework.boot.web.servlet.FilterRegistrationBean - Mapping filter: 'shiroFilter' to: [/*][INFO ] 2018-06-30 16:32:32,459 org.springframework.boot.web.servlet.FilterRegistrationBean - Mapping filter: 'logoutFilter' to: [/*] shiro配置文件中声明的bean，springboot会获取这个bean注册到FilterRegistrationBean 父类AbstractFilterRegistrationBean 如下所示：123456789101112131415161718192021222324252627282930313233343536private static final String[] DEFAULT_URL_MAPPINGS = new String[]&#123;"/*"&#125;;protected void configure(Dynamic registration) &#123; super.configure(registration); EnumSet dispatcherTypes = this.dispatcherTypes; if(dispatcherTypes == null) &#123; dispatcherTypes = EnumSet.of(DispatcherType.REQUEST); &#125; LinkedHashSet servletNames = new LinkedHashSet(); Iterator var4 = this.servletRegistrationBeans.iterator(); while(var4.hasNext()) &#123; ServletRegistrationBean servletRegistrationBean = (ServletRegistrationBean)var4.next(); servletNames.add(servletRegistrationBean.getServletName()); &#125; servletNames.addAll(this.servletNames); if(servletNames.isEmpty() &amp;&amp; this.urlPatterns.isEmpty()) &#123; this.logger.info("Mapping filter: \'" + registration.getName() + "\' to: " + Arrays.asList(DEFAULT_URL_MAPPINGS)); registration.addMappingForUrlPatterns(dispatcherTypes, this.matchAfter, DEFAULT_URL_MAPPINGS); &#125; else &#123; if(!servletNames.isEmpty()) &#123; this.logger.info("Mapping filter: \'" + registration.getName() + "\' to servlets: " + servletNames); registration.addMappingForServletNames(dispatcherTypes, this.matchAfter, StringUtils.toStringArray(servletNames)); &#125; if(!this.urlPatterns.isEmpty()) &#123; this.logger.info("Mapping filter: \'" + registration.getName() + "\' to urls: " + this.urlPatterns); registration.addMappingForUrlPatterns(dispatcherTypes, this.matchAfter, StringUtils.toStringArray(this.urlPatterns)); &#125; &#125; &#125;this.logger.info("Mapping filter: \'" + registration.getName() + "\' to: " + Arrays.asList(DEFAULT_URL_MAPPINGS)); 设置为/* 拦截所有 5.自定义 logoutFilter 过滤器12345678910111213 @Bean public FilterRegistrationBean filterRegistrationBean() &#123; FilterRegistrationBean registration = new FilterRegistrationBean(); LogoutFilter logoutFilter = new LogoutFilter(); logoutFilter.setRedirectUrl("/static/login.html"); registration.setFilter(logoutFilter); registration.addUrlPatterns("/logout"); registration.setName("logoutFilter"); return registration; &#125;需要放在配置类中，即有@Configuration注解修饰的类，@Bean表示这个bean，交给spring ioc 容器管理。 6.后来我在shiro配置文件中的 LogoutFilter 的相关配置去掉，在过滤链中保留 /logout = logout 也能正常退出，why？]]></content>
      <categories>
        <category>Spring Boot</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Laydate与Angularjs集成的取值问题]]></title>
    <url>%2Fblog%2F2018%2F05%2F31%2FLaydate%E4%B8%8EAngularjs%E9%9B%86%E6%88%90%E7%9A%84%E5%8F%96%E5%80%BC%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[laydate与angularjs集成 ng-model的取值问题 laydate-v5.0.9 上遍集成layer和laydate的问题只简单的用指令实现了日期选择器的调用，并未涉及到取值的问题。今天在造轮子的时候才遇到这个问题，这里将做个汇总记录。 采用自定义指令的方式集成laydate报错如下：1234567891011TypeError: Cannot read property 'toLocaleLowerCase' of undefined at T.isInput (file:///E:/work/springmvc-spring-mybatis-study/src/main/webapp/lib/jquery/laydate/laydate.js:573:47) at T.init (file:///E:/work/springmvc-spring-mybatis-study/src/main/webapp/lib/jquery/laydate/laydate.js:213:177) at file:///E:/work/springmvc-spring-mybatis-study/src/main/webapp/lib/jquery/laydate/laydate.js:51:15 at c (file:///E:/work/springmvc-spring-mybatis-study/src/main/webapp/lib/jquery/laydate/laydate.js:24:171) at Object.link (file:///E:/work/springmvc-spring-mybatis-study/src/main/webapp/lib/jquery/laydate/laydate.js:25:18) at Object.ready (file:///E:/work/springmvc-spring-mybatis-study/src/main/webapp/lib/jquery/laydate/laydate.js:39:50) at new T (file:///E:/work/springmvc-spring-mybatis-study/src/main/webapp/lib/jquery/laydate/laydate.js:50:80) at Object.n.render (file:///E:/work/springmvc-spring-mybatis-study/src/main/webapp/lib/jquery/laydate/laydate.js:588:17) at link (file:///E:/work/springmvc-spring-mybatis-study/src/main/webapp/modules/core/directives.js:12:25) at file:///E:/work/springmvc-spring-mybatis-study/src/main/webapp/lib/angular/angular.min.js:1829:38 &lt;input laydate="" class="ng-isolate-scope"&gt; 调试发现 return /input|textarea/.test(e.tagName.toLocaleLowerCase()) 这里的 e.tagName undefined ,原因是我们传进来的 e 是一个数组,因此改下我们的指令代码即可：123456789link: function(scope,el,attrs)&#123; var type = 'date'; var format = 'yyyy-MM-dd'; laydate.render(&#123; elem: el[0], // 把这里的el改为el[0] 搞定 type: type, format: format &#125;); &#125; ng-model取不到值通过指令集成之后，我们发现在使用的时候ng-model=”xxx”并不能获取到值，但是页面上是有值的。这个时候肯定是去找解决方案啊，百度了一大堆都指向这篇文章Angularjs 中使用 layDate 日期控件这个并不是我想要的，时间很久了，而且使用的时候还要搞个id属性麻烦。看了半天自己写的指令，并没有什么问题啊，就是取不到值，$watch也监听不到，后来只能使用laydate的回调方法试试。结果搞了半天还用错了，网上大多都是很早版本的，他们的回调方法都是choose，调试了半天没用。没办法了这才想起来去官网看下文档。一看才发现是选择完毕后的回调方法是done，还有个chang是在用上方的4个按钮触发的函数，这也是为什么我在标题上加了版本号。12345678910111213141516171819202122232425262728293031323334353637383940414243444546/*日期选择器指令，只能以元素的方式使用，使用方式如下: * &lt;laydate class="form-control" ng-model="searchData.theDate"&gt;&#123;&#123;searchData.theDate&#125;&#125;&lt;/laydate&gt; * &#123;&#123;searchData.theDate&#125;&#125; 一定要有这个，不然显示的数据会在一些特殊的情况下出现问题，这个下面会解释。 * @ngModel 绑定的数据 * @dateType 选择器的类型 可以不使用，默认 date * 参数类型 ：datetime 日期时间选择器 year 年选择器 month 年月选择器 date 日期选择器 time 时间选择器 * @format 自定义格式 可以不使用，默认 yyyy-MM-dd * 参数类型 ：参见 http://www.layui.com/doc/modules/laydate.html#format * */ .directive('laydate',[function()&#123; return&#123; restrict: 'E', scope: &#123; ngModel: '=', dateType: '@', format: '@' &#125;, link: function(scope,el,attrs)&#123; // 默认值 var type = 'date'; var format = 'yyyy-MM-dd'; if(scope.dateType)&#123; type = scope.dateType; &#125; if(scope.format)&#123; format = scope.format; &#125; laydate.render(&#123; elem: el[0], type: type, format: format, calendar: true, //显示节日 mark: &#123; //自定义标注重要日子 '0-12-31': '跨年', //每年的日期 '0-0-10': '工资' //每月某天 &#125;, done: function(data)&#123; scope.$apply(function()&#123; scope.ngModel = data; &#125;) &#125; &#125;); &#125; &#125; &#125;]) 这里说明下$watch监听不到值变化的原因：layate操作的是Html元素的方式是在调用的时候在页面上创建新的 HTML 元素（即选择日期框）,它是把选取到的数据绑定在了该元素上，可通过$(‘#id’).val()获取值，但是不能实现ng-model的数据绑定。所以我们用选择完毕后的回调方法done进行赋值done: function(data){scope.ngModel = data;},但是这个时候用$watch监听ngModel是不触发的，不论是在自定义指令还是在控制器里都监听不到值。因此需要使用$apply触发脏检查。done: function(data){scope.$apply(function(){scope.ngModel = data;})} 为什么一定要有这个，刚刚也讲到laydate是把选取到的数据绑定在了该元素上,所以如果不加展示的就是我们选择的值，并不是我们ng-model绑定的值，这里一般情况下并没有问题，但是特殊的情况下会出现问题，比如我们有开始日期和结束日期两个变量，一般都是复制粘贴的形式，所以会出现ng-model=”searchData.theDate”忘了改的情况，那这个时候按理来说忘了改关系也不大。但这个时候你去选择的时候会发现，我开始日期选得是2018-05-31，结束日期并没有值，选结束日期为201806-30的时候开始日期的值也没变还是原来的值。同一个变量为什么会不变呢，原因上面也说过了，这里展示的并不是ng-model绑定的变量值，而是把选取到的数据绑定在了该元素上而已，所以我们需要用把它覆盖掉，展示真正的数据。 至此该指令已经满足我现阶段的使用情况，对于些需要有日期选择范围限制的可自行修改，加几个参数就OK了。]]></content>
      <categories>
        <category>Angularjs</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Angularjsv1.2.20升级为1.6.8问题]]></title>
    <url>%2Fblog%2F2018%2F05%2F31%2FAngularjsv1_2_20%E5%8D%87%E7%BA%A7%E4%B8%BA1_6_8%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[Angularjsv1.2.20升级为1.6.8问题 v1.5 中$http 的 success 和 error 方法已废弃。使用 then 方法替代。： directives中，使用 = 双向绑定时，值不能及时刷新。更新了angularjs的版本后，几乎我所有的directives都受到了影响,select2、myPagination、laydate等，赋值部分都手动触发脏检查，使数据准确。]]></content>
      <categories>
        <category>Angularjs</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Git常用命令]]></title>
    <url>%2Fblog%2F2018%2F05%2F23%2FGit%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[Git常用命令 github page + hexo 博客点击分类,有些不能正常跳转，原因是因为之前分类用的是首字母小写的，后来改为首字符大写了，git默认不区分文件夹大小写（为了兼容Windows 不区分大小写吧）。到github上面一看，确实还是原来小写的文件夹，所以直接删除文件夹重新提交上传即可。 收集的git常用命令 git clone xxx.git –clone到本地 git clone xxx.git “指定目录” –clone到指定目录 git clone wyb@xxx.git –如果访问一个Git URL需要用户名和密码，可以在Git URL前加上用户名，并在它们之间加上@符合以表示分割，然后执行git clone命令，git会提示你输入密码 git branch –查看本地所有分支 git branch -r –查看远程所有分支 git branch -a –查看本地和远程所有分支(包括隐藏的)。 一般当前本地分支前带有“*”号且为绿色，远程分支为红色 git branch -D 分支名 –删除分支 （-d delete：删除，这里的-D delete和force（强制）的快捷键 是彻底删除） git clone -b [new_branch_name] xxx.git –clone时创建新的分支替代默认Origin HEAD（master） git add “文件目录/文件名”和git add . –将需要提交的文件添加进来，一次可以add多个不同的文件，以空格分隔。后者代表当前目录下所有文件提交到暂存区 git status和git status . –查看当前项目中代码状态。后者代表的是当前项目所有文件 git rm 我的文件 –在本地仓库删除文件 git rm -r 我的文件夹 –在本地仓库删除文件夹。此处-r表示递归所有子目录，如果你要删除的，是空的文件夹，此处可以不用带上-r git commit -m”我的修改内容注释” –提交代码到本地分支 git push origin master –提交到远端仓库,可以把 master 换成你想要推送的任何分支 git remote add origin xxx.git –如果还没有连接到某个远程服务器,则先建立远端仓库的别名 git remote remove origin –如有原来有个别名（如clone的别人的仓库到本地的情形），则需要先删除别名 git push -u origin master – 第一次推送master分支时，加上了 -u参数，Git不但会把内容推送的远程master分支，还会把本地的master分支和远程的master分支关联起来 git checkout 分支名 –切换分支 git checkout -t origin/dev 该命令等同于： git checkout -b dev origin/dev –在本地新建同名的(“dev”)分支，并切换到该分支 git pull origin 分支名 –将远端的代码拉到本地分支。如果有冲突，可以用git status查看有冲突的文件。pull=fetch+merge.fetch是将远端代码拉下来，merge是合并进去。 git log –显示从最近到最远的提交日志，如果嫌输出信息太多，看得眼花缭乱的，可以试试加上–pretty=oneline参数。需要友情提示的是，你看到的一大串类似2e70fd…376315的是commit id（版本号）。在 Git中，用HEAD表示当前版本，也就是最新的提交commit id，上一个版本就是HEAD^，上上一个版本就是HEAD^^，当然往上100个版本写100个^比较容易数不过来，所以写成HEAD~100。 git reset . –取消上次修改返回到上次提交状态 git reset –hard HEAD^ –把当前版本回退到上一个版本 git reset –hard 2e70fdf –指定回到某个版本 git reflog –记录你的每一次命令 详情参见Git常用命令Git 常用命令总结]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Atomikos分布式事务问题记录]]></title>
    <url>%2Fblog%2F2018%2F05%2F22%2FAtomikos%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[jta-atomikos多数据源分布式事务问题记录 javax.transaction.xa.XAException: java.sql.SQLException:无法创建 XA 控制连接。错误: 未能找到存储过程’master..xp_sqljdbc_xa_init’ 参考了解 XA 事务错误: 未能找到存储过程’master..xp_sqljdbc_xa_init’ MSDTC 服务不能启动的几个解决方法开始→运行→输入命令”net start msdtc”,运行该命令即可。如果启动不了，错误:msdtc无法启动，发生服务特定错误3221229584网上查找资料说：主要是系统无法找到MS DTC 日志文件造成的,只要创建一下就可以了:点开始→运行→输入命令”msdtc -resetlog”,运行该命令即可。之后,重新启动电脑,或者运行服务中的”Distributed Transaction Coordinator “服务均可. Error while retrieving xids from resource - will retry later…javax.transaction.xa.XAException: 函数 RECOVER: 失败。状态为: -3。错误:“ SQLJDBC_XA DTC_ERROR Context: xa_recover, state=1, StatusCode:-3 (0xFFFFFFFD) ”]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[添加链接服务器实现跨库访问]]></title>
    <url>%2Fblog%2F2018%2F05%2F22%2F%E6%B7%BB%E5%8A%A0%E9%93%BE%E6%8E%A5%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%9E%E7%8E%B0%E8%B7%A8%E5%BA%93%E8%AE%BF%E9%97%AE%2F</url>
    <content type="text"><![CDATA[SQL SERVER 添加链接服务器实现跨库访问 存储过程名/视图名 作用 举例 sp_addlinkedserver 注册远程数据库实例 exec sp_addlinkedserver ‘InstanceName’ sp_dropserver 删除远程数据库实例 exec sp_dropserver ‘InstanceName’ sp_addlinkedsrvlogin 注册远程实例登陆访问帐户 exec sp_addlinkedsrvlogin ‘InstanceName’, null sp_droplinkedsrvlogin 删除远程实例登陆访问帐户 EXEC sp_droplinkedsrvlogin ‘InstanceName’,’UserName’ sp_helpserver 当前实例已注册的可访问的实例(即查看使用sp_addlinkedserver已注册过的实例) sp_helpserver sys.sysservers 功能同sp_helpserver select * from sys.sysservers sys.linked_logins 查看已注册的登陆访问帐户(即查看使用sp_addlinkedsrvlogin已注册过的帐户) select * from sys.linked_logins sys.remote_logins 查看已注册的远端访问帐户 select * from sys.remote_logins Exec sp_droplinkedsrvlogin ZYB,Null –删除映射（录与链接服务器上远程登录之间的映射）Exec sp_dropserver ZYB –删除远程服务器链接 EXEC sp_addlinkedserver@server=’ZYB’,–被访问的服务器别名@srvproduct=’’,@provider=’SQLOLEDB’,@datasrc=”/Server2” –要访问的服务器 EXEC sp_addlinkedsrvlogin‘ZYB’, –被访问的服务器别名‘false’,NULL,‘sa’, –帐号‘sa’ –密码 使用实例：Select * from ZYB.CDCenter20110822.dbo.cardbase exec sp_catalogs srv_lnk–创建链接服务器 exec sp_addlinkedserver ‘srv_lnk’,’’,’SQLOLEDB’,’远程服务器名或ip地址’exec sp_addlinkedsrvlogin ‘srv_lnk’,’false’,null,’用户名’,’密码’go–查询示例 select from srv_lnk.数据库名.dbo.表名或select from srv_lnk.数据库名..表名 –返回在本地服务器上定义的链接服务列表 exec sp_linkedservers –返回指定链接服务器中的系统目录列表，在本地服务器中等价于数据库列表–连接不上会显示：SQL Server 不存在或拒绝访问。（判断远程SQL数据库连接状态是否正常） –以后不再使用时删除链接服务器 exec sp_dropserver ‘srv_lnk’,’droplogins’go–如果只是临时访问,可以直接用openrowset–查询示例 select * from openrowset(‘SQLOLEDB’,’sql服务器名’;’用户名’;’密码’,数据库名.dbo.表名)–导入示例 select into 表 from openrowset(‘SQLOLEDB’,’sql服务器名’;’用户名’;’密码’,数据库名.dbo.表名)select from openrowset(‘SQLOLEDB’,’sql服务器名’;’用户名’;’密码’,数据库名.dbo.表名)openrowset可以用下面两个OPENDATASOURCE或是openquery –a.在srv1..author中创建触发器,实现数据即时同步–新增同步create trigger tr_insert_author on authorfor insertasset xact_abort oninsert srv2.库名.dbo.author(id,name,telphone)select id,name,telphone from insertedgo –修改同步create trigger tr_update_author on authorfor updateasset xact_abort onupdate b set name=i.name,telphone=i.telphonefrom srv2.库名.dbo.author b,inserted iwhere b.id=i.idgo –删除同步create trigger tr_delete_author on authorfor deleteasset xact_abort ondelete bfrom srv2.库名.dbo.author b,deleted dwhere b.id=d.idgo]]></content>
      <categories>
        <category>SQL Server</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Spring注解默认命名规则采坑记录]]></title>
    <url>%2Fblog%2F2018%2F05%2F22%2FSpring%E6%B3%A8%E8%A7%A3%E5%91%BD%E5%90%8D%E8%A7%84%E5%88%99%E9%87%87%E5%9D%91%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[Spring注解默认命名规则采坑记录 由来之前在维科做APS（计划排产系统）的时候把原来框架xml配置式的改成Spring注解式的了，当时考虑后面有可能会搬到别的系统上去（即两个系统融合），为了防止类名冲突，就在写的时候把类名都加了APS做标识所以只要是APS的类都是APSXXXXX，这就为今天的事情埋下了坑。刚来新公司一个星期，突然维科的同事打电话说遇到些问题，让帮忙看下。初步沟通是在配置Struts文件的时候出了问题，然后电话排除了几个点，结果还是找不到这个类。尴尬了，远程吧。看了下该有的注解、配置都有，没问题啊什么鬼。后来就给这个控制类加了个命名@Controller(“XXXX”),这次可以了。（当时都是采用的默认生成bean名称的方式）这次就把问题定位在了Spring扫描时，默认生成bean名称的规则上。 原理如下：spring开发手册 自动检测组件的命名 当一个组件在某个扫描过程中被自动检测到时，会根据那个扫描器的BeanNameGenerator 策略生成它的bean名称BeanNameGenerator。 1.BeanNameGenerator接口位于 org.springframework.beans.factory.support 包下面，只声明了一个方法 generateBeanName(BeanDefinition var1, BeanDefinitionRegistry var2)，接受两个参数：var1 被生成名字的BeanDefinition实例；var2 生成名字后注册进的BeanDefinitionRegistry。 2.BeanNameGenerator有两个实现版本，DefaultBeanNameGenerator和AnnotationBeanNameGenerator。其中DefaultBeanNameGenerator是给资源文件加载bean时使用（BeanDefinitionReader中使用）；AnnotationBeanNameGenerator是为了处理注解生成bean name的情况。 3.AnnotationBeanNameGenerator是spring注解的默认生成策略，我们看一眼源码12345678910public String generateBeanName(BeanDefinition definition, BeanDefinitionRegistry registry) &#123; if(definition instanceof AnnotatedBeanDefinition) &#123; String beanName = this.determineBeanNameFromAnnotation((AnnotatedBeanDefinition)definition); if(StringUtils.hasText(beanName)) &#123; return beanName; &#125; &#125; return this.buildDefaultBeanName(definition, registry); &#125; if(definition instanceof AnnotatedBeanDefinition) 是否是BeanDefinition的子类AnnotatedBeanDefinition类型，是按照注解生成模式生成信息，否则生成默认的bean name 由 buildDefaultBeanName方法负责生成名称的实现。这里我们只看 buildDefaultBeanName 这个方法。 protected String buildDefaultBeanName(BeanDefinition definition) { String shortClassName = ClassUtils.getShortName(definition.getBeanClassName()); return Introspector.decapitalize(shortClassName); } definition.getBeanClassName()是获取全限定名称的 ClassUtils.getShortName()源码 public static String getShortName(String className) { Assert.hasLength(className, "Class name must not be empty"); int lastDotIndex = className.lastIndexOf(46); int nameEndIndex = className.indexOf("$$"); if(nameEndIndex == -1) { nameEndIndex = className.length(); } String shortName = className.substring(lastDotIndex + 1, nameEndIndex); shortName = shortName.replace('$', '.'); return shortName; } Introspector.decapitalize()源码 public static String decapitalize(String name) { if (name == null || name.length() == 0) { return name; } if (name.length() &gt; 1 &amp;&amp; Character.isUpperCase(name.charAt(1)) &amp;&amp; Character.isUpperCase(name.charAt(0))){ return name; } char chars[] = name.toCharArray(); chars[0] = Character.toLowerCase(chars[0]); return new String(chars); } 这下终于明白了吧，如果第一个和第二个字符都是大写的字母开头则返回，扫描进来的bean就是大写开头的，其他的则是把第一个字符小写返回，扫描进来的是小写开头。至此已经解释了我们今天遇到的问题，其他分支想了解的时候可自行百度。另外如果想自定义注解命名规则可使用name-generator属性。 context:component-scan的name-generator属性 自定义Spring Bean注解命名规则]]></content>
      <categories>
        <category>Spring</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Navicat连接Orcale问题]]></title>
    <url>%2Fblog%2F2018%2F05%2F08%2FNavicat%E8%BF%9E%E6%8E%A5Orcale%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[Navicat连接Orcale问题 ORA-28547：connection to server failed, probable Oracle Net admin error 网上关于这个错误的回答有很多，主要是说Navicat的oci.dll版本问题。 因为Navicat是通过Oracle客户端连接Oracle服务器的，Oracle的客户端分为两种，一种是标准版，一种是简洁版，即Oracle Install Client。而我们用Navicat时通常会在自己的安装路径下包含多个版本的OCI，如果使用Navicat连接Oracle服务器出现ORA-28547错误时，多数是因为Navicat本地的OCI版本与Oracle服务器服务器不符造成的。所以我们要做的就是下载OCI使之与我们所安装的Oracle服务器相符合 看了下我装的Navicat版本只有instantclient_10_2，所以就去找instantclient_11_2，结果orcale官网还需要登陆才能下载。懒得注册就想着下一个高版本的Navicat应该会绑定个高版本的oci.dll，然后就去安装了Navicat Premium 12.0.27，支持连接SQL Server、MySQL、Oracle、SQLite、阿里云、腾讯云、微软、亚马逊等等很多种数据库，文末有教程连接。安装、激活完成后一看，我擦嘞。。。还是只有instantclient_10_2。么的办法，饶了一圈又回来了，只能orcale官网注册下载Instant Client了。不过还是有收获的，可以把电脑上的其他版本的Navicat卸载了（Navicat for SQL Server、MySQL、Navicat For Orcale）。 另外，Oracle9i或以上版本的，要安装Install Client11或以下；Oracle8或8i服务器，需要安装Install Client10或以下，现在的Oracle一般都是都是10以上了。 然后在Navicat中配置一下，选择 工具-选项-其他-OCI 或 工具-选项-环境-OCI环境选择相应的oci.dll即可。 Oracle Instant Client Downloads（各种版本Windows、Linux、Mac）Instant Client下载适用于 Microsoft Windows (x64)(中文)Navicat Premium 12.0.27安装与激活]]></content>
      <categories>
        <category>Navicat</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[集成Layer和Laydate的问题]]></title>
    <url>%2Fblog%2F2018%2F04%2F27%2F%E9%9B%86%E6%88%90Layer%E5%92%8CLaydate%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[集成Layer和Laydate的问题 本来我用的提示工具是toastr，后来发现还需要一个confirm的对话框，偶然逛github的时候看到有人提到了这个layer弹层组件，因此知道了layui这个UI框架，官网浏览选中了layer、laydate两个组件。 layer由于不晓得以后是否会改用其他的弹层组件、所以想集中管理layer的使用。因此想写成一个服务去使用，这样即使后来改成其他的组件，也只需要改动服务这块的代码即可(alert、msg、tips等等都可以这样)。1234567891011121314151617181920212223242526272829303132333435363738394041424344.factory('ConfirmService', [function () &#123; return &#123; confirm: function (title, content, yesFunction, noFunction) &#123; layer.confirm(content, &#123; title: title, btn: ['确定', '取消'] //按钮 &#125;, function (index) &#123; yesFunction(); layer.close(index); &#125;, function () &#123; if (angular.isFunction(noFunction)) &#123; noFunction(); &#125; &#125;); &#125;, alert: function(content)&#123; layer.alert(content, &#123; closeBtn: 0, anim: 1 //动画类型 &#125;); &#125;, message: function(content)&#123; layer.msg(content, &#123; offset:'t', shift:0, time:1200 &#125;); &#125; &#125;&#125;])此时只需要在需要使用的controller里注入该服务即可，使用方式如下：$scope.doDelete = function(id)&#123; $scope.delId = id; ConfirmService.confirm('提示', '确定删除该数据吗？', $scope.yesDelete,null);&#125;$scope.yesDelete = function () &#123; var url = '***********?id='+$scope.delId; ConfirmService.alert(11111); ConfirmService.message(11111); //do something&#125; laydate采用自定义指令的方式集成laydate报错如下：1234567891011TypeError: Cannot read property 'toLocaleLowerCase' of undefined at T.isInput (file:///E:/work/springmvc-spring-mybatis-study/src/main/webapp/lib/jquery/laydate/laydate.js:573:47) at T.init (file:///E:/work/springmvc-spring-mybatis-study/src/main/webapp/lib/jquery/laydate/laydate.js:213:177) at file:///E:/work/springmvc-spring-mybatis-study/src/main/webapp/lib/jquery/laydate/laydate.js:51:15 at c (file:///E:/work/springmvc-spring-mybatis-study/src/main/webapp/lib/jquery/laydate/laydate.js:24:171) at Object.link (file:///E:/work/springmvc-spring-mybatis-study/src/main/webapp/lib/jquery/laydate/laydate.js:25:18) at Object.ready (file:///E:/work/springmvc-spring-mybatis-study/src/main/webapp/lib/jquery/laydate/laydate.js:39:50) at new T (file:///E:/work/springmvc-spring-mybatis-study/src/main/webapp/lib/jquery/laydate/laydate.js:50:80) at Object.n.render (file:///E:/work/springmvc-spring-mybatis-study/src/main/webapp/lib/jquery/laydate/laydate.js:588:17) at link (file:///E:/work/springmvc-spring-mybatis-study/src/main/webapp/modules/core/directives.js:12:25) at file:///E:/work/springmvc-spring-mybatis-study/src/main/webapp/lib/angular/angular.min.js:1829:38 &lt;input laydate="" class="ng-isolate-scope"&gt; 调试发现 return /input|textarea/.test(e.tagName.toLocaleLowerCase()) 这里的 e.tagName undefined ,原因是我们传进来的 e 是一个数组,因此改下我们的指令代码即可：123456789link: function(scope,el,attrs)&#123; var type = 'date'; var format = 'yyyy-MM-dd'; laydate.render(&#123; elem: el[0], // 把这里的el改为el[0] 搞定 type: type, format: format &#125;); &#125;]]></content>
      <categories>
        <category>Layui</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[集成Shiro+Ehcache+Druid+Log4J的问题]]></title>
    <url>%2Fblog%2F2018%2F04%2F18%2F%E9%9B%86%E6%88%90Shiro%2BEhcache%2BDruid%2BLog4J%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[集成Shiro+Ehcache+Druid+Log4J等遇到的问题 Shiro验证URL的规则Shiro验证URL时,URL匹配成功便不再继续匹配查找(所以要注意配置文件中的URL顺序,尤其在使用通配符时)/** = authc 类似这种 所以这个一定要放在最后，如果放在最前面、则后面所有的都会失效。 动态加载权限过滤的时候踩过坑 默认过滤器(10个)12345678910111213141516171819anon -- org.apache.shiro.web.filter.authc.AnonymousFilter authc -- org.apache.shiro.web.filter.authc.FormAuthenticationFilter authcBasic -- org.apache.shiro.web.filter.authc.BasicHttpAuthenticationFilter perms -- org.apache.shiro.web.filter.authz.PermissionsAuthorizationFilter port -- org.apache.shiro.web.filter.authz.PortFilter rest -- org.apache.shiro.web.filter.authz.HttpMethodPermissionFilter roles -- org.apache.shiro.web.filter.authz.RolesAuthorizationFilter ssl -- org.apache.shiro.web.filter.authz.SslFilter user -- org.apache.shiro.web.filter.authc.UserFilter logout -- org.apache.shiro.web.filter.authc.LogoutFilter anon:例子/admins/**=anon 没有参数，表示可以匿名使用。 authc:例如/admins/user/**=authc表示需要认证(登录)才能使用，没有参数 roles：例子/admins/user/**=roles[admin],参数可以写多个，多个时必须加上引号，并且参数之间用逗号分割，当有多个参数时，例如admins/user/**=roles["admin,guest"],每个参数通过才算通过，相当于hasAllRoles()方法。 perms：例子/admins/user/**=perms[user:add:*],参数可以写多个，多个时必须加上引号，并且参数之间用逗号分割，例如/admins/user/**=perms["user:add:*,user:modify:*"]，当有多个参数时必须每个参数都通过才通过，想当于isPermitedAll()方法。 rest：例子/admins/user/**=rest[user],根据请求的方法，相当于/admins/user/**=perms[user:method] ,其中method为post，get，delete等。 port：例子/admins/user/**=port[8081],当请求的url的端口不是8081是跳转到schemal://serverName:8081?queryString,其中schmal是协议http或https等，serverName是你访问的host,8081是url配置里port的端口，queryString是你访问的url里的？后面的参数。 authcBasic：例如/admins/user/**=authcBasic没有参数表示httpBasic认证 ssl:例子/admins/user/**=ssl没有参数，表示安全的url请求，协议为https user:例如/admins/user/**=user没有参数表示必须存在用户，当登入操作时不做检查 获取 shiroFilter的实例当需要得到名为”shiroFilter“的bean时，调用其getObject()来获取实例.ShiroFilterFactoryBean源码及拦截原理深入分析 无法访问 filter重新加载权限过滤链时shiroFilter.getFilterChainResolver()一直卡在这句上被搞死了，一直用的jetty容器，一直编译不通过，报错是 无法访问 filter,一直找不到原因终于在用tomcat容器的时候才完整的看到提示信息：Error:(39, 110) java: 无法访问javax.servlet.Filter找不到javax.servlet.Filter的类文件擦，原来是没有这jar包,引入 servlet-api jar包 通过。由于缺少这个jar包导致无法访问到 shiroFilter.getFilterChainResolver();这个jar 里有访问 filter 的接口类 javax.servlet.Filter。 12345678910111213141516&lt;!--被这个包搞死了--&gt;&lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;servlet-api&lt;/artifactId&gt; &lt;version&gt;2.5&lt;/version&gt; &lt;!--&lt;scope&gt;provided&lt;/scope&gt;--&gt;&lt;/dependency&gt;如果不同版本的包之间也会造成冲突问题，解决这个问题的方法就是对于servlet-ap.jar使用 &lt;scope&gt;标签，编译的时候用到servlet-api和jsp-api，但在打包的时候不用这两个依赖&lt;dependency&gt;中&lt;scope&gt;，它主要管理依赖的部署。目前&lt;scope&gt;可以使用5个值：* compile，缺省值，适用于所有阶段，会随着项目一起发布。* provided，类似compile，期望JDK、容器或使用者会提供这个依赖。如servlet.jar。* runtime，只在运行时使用，如JDBC驱动，适用运行和测试阶段。* test，只在测试时使用，用于编译和运行测试代码。不会随项目发布。* system，类似provided，需要显式提供包含依赖的jar，Maven不会在Repository中查找它。 使用Shiro注解方式验证(我的项目并未用这种方式，这里记录下)说明：使用shiro注解 以下配置必须放在 spring-mvc的配置文件里，因为shiro的注解授权是利用Spring的AOP实现的。在程序启动时会自动扫描作了注解的Class，当发现注解时，就自动注入授权代码实现。也就是说，要注入授权控制代码，第一处必须要让框架要可以扫描找被注解的Class 。而我们的Srping项目在applicationContext.xml中一般是不扫描Controller的，所以也就无法让写在Controller中的注解授权生效了。因此正确的作法是将这配置放到spring-mvc的配置文件中.这样Controller就可以通过注解授权了。同样的道理，如果service层也需要注解授权，那就需要在spring的applicationContext.xml配置文件中再配置一遍。 12345678910111213141516171819202122232425262728&lt;!-- 保证实现了Shiro内部lifecycle函数的bean执行 Shiro注解依赖该Bean,必须在该bean之后运行--&gt; &lt;bean id="lifecycleBeanPostProcessor" class="org.apache.shiro.spring.LifecycleBeanPostProcessor"/&gt; &lt;!-- AOP式方法级权限检查 --&gt; &lt;bean class="org.springframework.aop.framework.autoproxy.DefaultAdvisorAutoProxyCreator" depends-on="lifecycleBeanPostProcessor"&gt; &lt;property name="proxyTargetClass" value="true"/&gt; &lt;/bean&gt; &lt;!-- 启用shrio 控制器授权注解拦截方式 --&gt; &lt;bean class="org.apache.shiro.spring.security.interceptor.AuthorizationAttributeSourceAdvisor"&gt; &lt;property name="securityManager" ref="securityManager"/&gt; &lt;/bean&gt; &lt;!--说明： 使用shiro注解授权后，上面配置的没有权限跳转的URL就失效了 --&gt; &lt;!--解决方法：在 spring-mvc中加入如下配置：--&gt; &lt;!-- shiro为集成springMvc 拦截异常--&gt; &lt;bean class="org.springframework.web.servlet.handler.SimpleMappingExceptionResolver"&gt; &lt;property name="exceptionMappings"&gt; &lt;props&gt; &lt;!-- 这里你可以根据需要定义N多个错误异常转发 --&gt; &lt;prop key="org.apache.shiro.authz.UnauthorizedException"&gt;redirect:/unauth.html&lt;/prop&gt; &lt;prop key="org.apache.shiro.authz.UnauthenticatedException"&gt;redirect:/unauth.html&lt;/prop&gt; &lt;prop key="java.lang.IllegalArgumentException"&gt;/error.jsp&lt;/prop&gt; &lt;!-- 参数错误(bizError.jsp) --&gt; &lt;prop key="java.lang.Exception"&gt;/error.jsp&lt;/prop&gt; &lt;!-- 其他错误为'未定义错误'(unknowError.jsp) --&gt; &lt;/props&gt; &lt;/property&gt; &lt;/bean&gt; slf4j日志无法写入开始是因为只配置了log4j.properties这个配置文件，未引入jar包，引入 slf4j-api jar 包后 log.info()还是不能输出原因：slf4j只是一个日志标准，并不是日志系统的具体实现。slf4j-simple、logback都是slf4j的具体实现，log4j并不直接实现slf4j，但是有专门的一层桥接slf4j-log4j12来实现slf4j详情参见：Java日志框架：slf4j作用及其实现原理Java日志框架—SLF4J 1234567891011121314151617&lt;!--slf4j 日志包--&gt;&lt;!--使用适配器类举例 SLF4J++Log4J 方案--&gt;&lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt; &lt;version&gt;1.7.25&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt; &lt;version&gt;1.7.12&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.17&lt;/version&gt;&lt;/dependency&gt; Ehcache 问题Spring中配置 ehcache 首先要定义 ehcache 缓存配置 引入 配置文件。然后 spring 和 shiro 分别封装ehcache缓存管理器,此时要引入相关jar包。shiroCacheManager 这个 bean 在 shiro 配置文件中 注入给相关需要缓存的bean eg：securityManager、sessionDAO 12345678910111213141516171819202122232425262728293031&lt;!--ehcache 缓存配置--&gt;&lt;bean id="ehCacheManager" class="org.springframework.cache.ehcache.EhCacheManagerFactoryBean"&gt; &lt;property name="configLocation" value="classpath:ehcache.xml"/&gt; &lt;property name="shared" value="true"&gt;&lt;/property&gt;&lt;/bean&gt;&lt;!-- spring 封装ehcache缓存管理器 --&gt;&lt;bean id="springCacheManager" class="org.springframework.cache.ehcache.EhCacheCacheManager"&gt; &lt;property name="cacheManager" ref="ehCacheManager"/&gt;&lt;/bean&gt;&lt;!-- shiro封装cacheManager --&gt;&lt;bean id="shiroCacheManager" class="org.apache.shiro.cache.ehcache.EhCacheManager"&gt; &lt;property name="cacheManager" ref="ehCacheManager" /&gt;&lt;/bean&gt;&lt;!-- ehcache缓存框架 --&gt;&lt;dependency&gt; &lt;groupId&gt;net.sf.ehcache&lt;/groupId&gt; &lt;artifactId&gt;ehcache-core&lt;/artifactId&gt; &lt;version&gt;2.4.8&lt;/version&gt;&lt;/dependency&gt;&lt;!--shiro ehcache--&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt; &lt;artifactId&gt;shiro-ehcache&lt;/artifactId&gt; &lt;version&gt;$&#123;shiro.version&#125;&lt;/version&gt;&lt;/dependency&gt;&lt;!-- Spring 整合 ehcache 包 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context-support&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;&lt;/dependency&gt; 数据库连接用druid遇到的问题数据库为 sqlserver2008 驱动为 sqljdbc3.0 开始用的dbcp 后来想用 druid 因为他有各种监控，首先导入jar包用的是最新版本，然后开始启动项目，他奶奶的一直启动不了，tomcat8 跑 错误是 ClassNotFound,很是奇怪，jetty 8 跑，一直卡在 (DruidDataSource.java:785) {dataSource-1} inited 不动，各种百度找了很久，找不到原因,很苦恼明明导入了jar包，而且点击 &lt;bean id=&quot;dataSource&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot; init-method=&quot;init&quot; destroy-method=&quot;close&quot;&gt; 也能到 DruidDataSource 这个类里去，就是不知道原因在哪，后来想是不是版本太新了，然后到maven仓库里看了下有好几个版本 然后就改用了 1.0.28版。还是不行，跟上面一样的结果，又是一顿百度啊，还是解决不了，后来改成 1.0.18的时候 用jetty 8 跑竟然可以了，但是tomcat 8 依然是ClassNotFound，一直不知道什么原因。 12345&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.1.6&lt;/version&gt;&lt;/dependency&gt; 引入Ehcache，修改用户密码时，退出登陆后，登录时不能及时生效因为用了authenticationCache，设置的是1小时候才会从缓存中移除。所以退出登录后并不能及时生效,需要手动清除该用户的认证缓存。]]></content>
      <categories>
        <category>搭框架问题记录</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[使用Spring注解遇到的问题]]></title>
    <url>%2Fblog%2F2018%2F04%2F17%2F%E4%BD%BF%E7%94%A8Spring%E6%B3%A8%E8%A7%A3%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[使用Spring注解遇到的问题 使用注解方式必须保证映射器和适配器都采用注解包下的，必须配套使用。不能一个注解，一个非注解12345678org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping" /&gt; 非注解映射器org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter非注解适配器org.springframework.web.servlet.mvc.annotation.DefaultAnnotationHandlerMapping 注解映射器org.springframework.web.servlet.mvc.annotation.AnnotationMethodHandlerAdapter.class注解适配器 当然可以使用 mvc:annotation-driven代替上边注解映射器和注解适配器配置mvc:annotation-driven默认加载很多的参数绑定方法，比如json转换解析器就默认加载了，如果使用mvc:annotation-driven不用配置上边的RequestMappingHandlerMapping和RequestMappingHandlerAdapter实际开发时使用mvc:annotation-driven SpringMVC中当在浏览器中输入对应的MappingUrl时，报The resource identified by this request is only capable of generating responses with characteristics not acceptable according to the request “accept” headers.错误的意思是：说是指定的资源已经找到，但它的MIME类型和客户在Accpet头中所指定的不兼容 原因：这里是因为我们使用了springMVC的@ResponseBody注解,@ResponseBody表示该方法的返回结果直接写入HTTP response body中。一般在异步获取数据时使用，在使用@RequestMapping后，返回值通常解析为跳转路径，加上@ResponseBody后返回结果不会被解析为跳转路径，而是直接写入HTTP response body中。比如异步获取json数据，加上@ResponseBody后，会直接返回json数据。@ResponseBody返回json格式的数据，而浏览器接受的是text/html;charset=UTF-8文本类型 解决：12345678910111213141516171819202122232425262728293031323334353637 &lt;!--json所需要的依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-core&lt;/artifactId&gt; &lt;version&gt;2.7.3&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;2.7.3&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-annotations&lt;/artifactId&gt; &lt;version&gt;2.7.3&lt;/version&gt; &lt;/dependency&gt; 如果使用的是 mvc:annotation-driven 则不需要配置。&lt;!--转化json 在springmvc配置文件中配置对应的bean--&gt;&lt;bean class="org.springframework.web.servlet.mvc.annotation.AnnotationMethodHandlerAdapter"&gt; &lt;property name="messageConverters"&gt; &lt;list&gt; &lt;ref bean="mappingJacksonHttpMessageConverter" /&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!--json转化器，它可以将结果转化--&gt; &lt;bean id="mappingJacksonHttpMessageConverter" class="org.springframework.http.converter.json.MappingJackson2HttpMessageConverter"&gt; &lt;property name="supportedMediaTypes"&gt; &lt;list&gt; &lt;value&gt;application/json;charset=UTF-8&lt;/value&gt; &lt;value&gt;text/html;charset=UTF-8&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt;]]></content>
      <categories>
        <category>搭框架问题记录</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Mybatis动态多数据源]]></title>
    <url>%2Fblog%2F2018%2F04%2F16%2FMyBatis%E5%8A%A8%E6%80%81%E5%A4%9A%E6%95%B0%E6%8D%AE%E6%BA%90%2F</url>
    <content type="text"><![CDATA[Mybatis动态多数据源 最近碰到多数据源的问题，之前处理过Ibatis的多数据源，也没怎么考虑事务的问题。目前自己搭的框架用的是Mybatis,所以就找了下相关的博客 为什么MyBatis的Mapper接口没有实现类，但是可以直接用MyBatis使用Java动态代理实现的接口,以下提供两遍文章去理解，也可自行百度。MyBatis接口的简单实现原理MyBatis框架及原理分析 简单来说（原理）MyBatis应用程序根据XML配置文件创建SqlSessionFactory，SqlSessionFactory根据配置获取一个SqlSession。SqlSession包含了执行sql所需要的所有方法，可以通过SqlSession实例直接运行映射的sql语句，完成对数据的增删改查和事务提交等，用完之后关闭SqlSession。 相关配置MyBatis可以配置多种环境（开发、测试和生产环境），但是每个SqlSessionFactory 实例只能选择一个环境。每个数据库对应一个SqlSessionFactory 实例。所以，如果你想连接两个数据库，就需要创建两个SqlSessionFactory 实例，每个数据库对应一个。而如果是三个数据库，就需要三个实例，依此类推。 环境示例配置如下:12345678910111213&lt;environments default="development"&gt; &lt;environment id="development"&gt; &lt;transactionManager tybe="JDBC"&gt; &lt;property name="..." value="..."/&gt; &lt;/transactionManager&gt; &lt;dataSource type="POOLED" &gt; &lt;property name="driver" value="$&#123;driver&#125;"/&gt; &lt;property name="ur1" value="$&#123;url&#125;"/&gt; &lt;property name="username" value="$&#123;username&#125;"/&gt; &lt;property name="password" value="$&#123;password&#125;"/&gt; &lt;/dataSource&gt; &lt;/environment&gt;&lt;/environments&gt; 多数据源配置如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980&lt;bean id="dataSource2" class="com.alibaba.druid.pool.DruidDataSource" init-method="init" destroy-method="close"&gt; &lt;property name="driverClassName" value="$&#123;jdbc.db1.driverClassName&#125;" /&gt; &lt;property name="url" value="$&#123;jdbc.db1.url&#125;" /&gt; &lt;property name="username" value="$&#123;jdbc.db1.username&#125;" /&gt; &lt;property name="password" value="$&#123;jdbc.db1.password&#125;" /&gt; &lt;property name="initialSize" value="5" /&gt; &lt;property name="maxActive" value="15" /&gt; &lt;property name="removeAbandoned" value="true" /&gt; &lt;property name="removeAbandonedTimeout" value="1800" /&gt; &lt;property name="logAbandoned" value="true" /&gt; &lt;property name="maxWait" value="3000" /&gt; &lt;property name="timeBetweenEvictionRunsMillis" value="60000" /&gt; &lt;property name="minEvictableIdleTimeMillis" value="300000" /&gt; &lt;property name="defaultTransactionIsolation" value="300000" /&gt; &lt;property name="validationQuery"&gt; &lt;value&gt;SELECT 1&lt;/value&gt; &lt;/property&gt; &lt;property name="testOnBorrow"&gt; &lt;value&gt;true&lt;/value&gt; &lt;/property&gt; &lt;property name="filters" value="mergeStat,wall" /&gt;&lt;/bean&gt;&lt;bean id="dataSource2" class="com.alibaba.druid.pool.DruidDataSource" init-method="init" destroy-method="close"&gt; &lt;property name="driverClassName" value="$&#123;jdbc.db2.driverClassName&#125;" /&gt; &lt;property name="url" value="$&#123;jdbc.db2.url&#125;" /&gt; &lt;property name="username" value="$&#123;jdbc.db2.username&#125;" /&gt; &lt;property name="password" value="$&#123;jdbc.db2.password&#125;" /&gt; &lt;property name="initialSize" value="5" /&gt; &lt;property name="maxActive" value="15" /&gt; &lt;property name="removeAbandoned" value="true" /&gt; &lt;property name="removeAbandonedTimeout" value="1800" /&gt; &lt;property name="logAbandoned" value="true" /&gt; &lt;property name="maxWait" value="3000" /&gt; &lt;property name="timeBetweenEvictionRunsMillis" value="60000" /&gt; &lt;property name="minEvictableIdleTimeMillis" value="300000" /&gt; &lt;property name="defaultTransactionlsoltionLevel" value="300000" /&gt; &lt;property name="validationQuery"&gt; &lt;value&gt;SELECT 1&lt;/value&gt; &lt;/property&gt; &lt;property name="testOnBorrow"&gt; &lt;value&gt;true&lt;/value&gt; &lt;/property&gt; &lt;property name="filters" value="mergeStat,wall" /&gt;&lt;/bean&gt;&lt;bean id="sqlSessionFactory1" class="org.mybatis.spring.SqlSessionFactoryBean"&gt; &lt;property name="dataSource" ref="dataSource1" /&gt; &lt;property name="configLocation" value="classpath:sqlmap-config.xml" /&gt;&lt;/bean&gt;&lt;bean id="sqlSessionFactory2" class="org.mybatis.spring.SqlSessionFactoryBean"&gt; &lt;property name="dataSource" ref="dataSource1" /&gt; &lt;property name="configLocation" value="classpath:sqlmap-config.xml" /&gt;&lt;/bean&gt;&lt;bean class="org.mybatis.spring.mapper.MapperScannerConfigurer"&gt; &lt;property name="sqlSessionFactoryBeanName" value="sqlSessionFactory1"&gt;&lt;/property&gt; &lt;property name="basePackage" value="com.wyb.**.dao" /&gt;&lt;/bean&gt;&lt;bean class="org.mybatis.spring.mapper.MapperScannerConfigurer"&gt; &lt;property name="sqlSessionFactoryBeanName" value="sqlSessionFactory2"&gt;&lt;/property&gt; &lt;property name="basePackage" value="com.wyb.**.dao" /&gt;&lt;/bean&gt; 记录下使用mybatis的两种方式12345678910111213141516171819202122232425&lt;bean id="sqlSessionFactory" class="org.mybatis.spring.SqlSessionFactoryBean"&gt; &lt;property name="dataSource" ref="dataSource" /&gt; &lt;!--方式一： 引入mybatis配置文件的方式 --&gt; &lt;property name="configLocation" value="classpath:sys-sqlmap-config.xml" /&gt; &lt;!--方式二： 直接使用的方式 --&gt; &lt;!--&lt;property name="typeAliasesPackage" value="com.wyb.crm.entity"/&gt;--&gt; &lt;!-- 当mybatis的xml文件和mapper接口不在相同包下时，需要用mapperLocations属性指定xml文件的路径。 *是个通配符，代表所有的文件，**代表所有目录下 --&gt; &lt;!--&lt;property name="mapperLocations" value="classpath:sqlmap/*.xml" /&gt;--&gt; &lt;!-- 多个路径--&gt; &lt;!--&lt;property name="mapperLocations"&gt; &lt;array&gt; &lt;value&gt;classpath:sqlmap/*.xml&lt;/value&gt; &lt;value&gt;classpath:sqlmap2/*.xml&lt;/value&gt; &lt;/array&gt; &lt;/property&gt;--&gt; &lt;!--因为Mapper.xml与Mapper.class不在同一个包下或者不同名，就必须使用配置mapperLocations指定mapper.xml的位置。 此时spring是通过识别mapper.xml中的 &lt;mapper namespace="com.wyb.crm.dao.studentMapper"&gt;来确定对应的Mapper.class的。 如果Mapper.xml与Mapper.class在同一个包下且同名，spring扫描Mapper.class的同时会自动扫描同名的Mapper.xml并装配到Mapper.class。 --&gt;&lt;/bean&gt; 问题：多数据源的事务管理怎么处理，我们这里数据库之间没有相关性也不是主从库。所以采用分别进行事务的配置，但是这种配置是不支持分布式事务的，也就是同一个事务中，不能操作多个数据库。怎么破？(待解决) 暂时先采用下面这种方式解决：服务a和b，分别操作一个数据库，如果a中调用b服务，这时候实际上a服务是操作了多个数据源的。为了要保证事务一致性，需要判断b服务的返回结果（处理状态），如果b服务中出现异常，那我们就try catch b 服务，并且在a中把这个异常抛出，这样就可以实现 a、b两个事务都回滚了。（麻烦） 以下提供几遍相关的文章：Spring, MyBatis 多数据源的配置和管理多数据源配置情况下的事务管理Spring中实现多数据源事务管理 这里记录几个常用的属性parameterType。将会传入这条语句的参数类的完全限定名或别名。这个属性是可选的，因为MyBatis 可以通过TypeHandler 推断出具体传入语句的参数，默认值为unset。resultType。从这条语句中返回的期望类型的类的完全限定名或别名。注意如果是集合情形，那应该是集合可以包含的类型,而不能是集合本身。返回时可以使用resultType或resultMap，但不能同时使用。resultMap。外部resultMap 的命名引用。结果集的映射是MyBatis 最强大的特性，对其有一个很好的理解的话，许多复杂映射的情形都能迎刃而解。返回时可以使用resultMap 或resultType,但不能同时使用。 更多MyBatis的介绍（特点、SqlSessionFactory、SqlSession、配置文件详解等）请参见MyBatis中国分站]]></content>
      <categories>
        <category>Mybatis</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[文章收集]]></title>
    <url>%2Fblog%2F2018%2F04%2F12%2F%E6%96%87%E7%AB%A0%E6%94%B6%E9%9B%86%2F</url>
    <content type="text"><![CDATA[文章收集 静态资源版本更新与缓存 toString的性能 Java 并发的四种风味：Thread、Executor、ForkJoin 和 Acto 计算并发量的方法 生成、扫描条码的三种方式barcode4j、jbarcode、zxing ZXing Core Maven仓库引用 5.1 ZXing中QR码相关部分了解 5.2 Zxing和QR CODE生成与解析二维码实例 如何优雅的设计java异常 如何快速开发一个 Dubbo 应用 图解基于HTTPS的DNS9.SpringMVC中使用拦截器（interceptor）拦截CSRF攻击（修）10.SpringMVC中使用Interceptor+cookie实现在一定天数之内自动登]]></content>
      <categories>
        <category>Other</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[安装、使用Redis]]></title>
    <url>%2Fblog%2F2018%2F04%2F10%2F%E5%AE%89%E8%A3%85%E3%80%81%E4%BD%BF%E7%94%A8Redis%2F</url>
    <content type="text"><![CDATA[使用Redis过程中的问题收集 各版本下载地址windows版本下载 1.windows下使用Redis下载相关包后，右键解压Redis ZIP包。cmd 进入到redis目录下，使用 redis-server.exe redis.windows.conf 启动redis服务，doc窗口不要关闭，关闭服务就停了。127.0.0.1:6379 默认是6379端口，可在redis.windows.conf中更改，同样可以搜索 SECURITY 找到 requirepass 设置密码，eg: requirepass 123456新打开一个doc窗口进入到redis目录下，使用 redis-cli.exe 自带的客户端工具测试，eg: set name qq 如果设置密码则需要认证，get name 即可获得 qq,以下是一些基础命令：1234567keys * 或 keys "*" --查看所有keykeys "miao*" --查看匹配前缀的keysflushdb --清空redisrandomkey --随机取出一个keytype key --查看key的类型dbsize --查看数据库中key的数量info --查看服务器信息]]></content>
      <categories>
        <category>Redis</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Windows安装虚拟机使用Linux系统]]></title>
    <url>%2Fblog%2F2018%2F04%2F10%2F%E5%AE%89%E8%A3%85%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%8C%E4%BD%BF%E7%94%A8Linux%E7%B3%BB%E7%BB%9F%2F</url>
    <content type="text"><![CDATA[Windows安装虚拟机、Linux过程中的问题收集 1.首先准备VMware和Linux操作系统镜像 2.VMware这个软件百度搜下，安装教程很多。我用的版本是14.1.1.28517，这里为了方便以后查找记录几个永久激活密钥。感谢博主渣渣潘123456789CG54H-D8D0H-H8DHY-C6X7X-N2KG6ZC3WK-AFXEK-488JP-A7MQX-XL8YFAC5XK-0ZD4H-088HP-9NQZV-ZG2R4ZC5XK-A6E0M-080XQ-04ZZG-YF08DZY5H0-D3Y8K-M89EZ-AYPEG-MYUA8FF590-2DX83-M81LZ-XDM7E-MKUT4FF31K-AHZD1-H8ETZ-8WWEZ-WUUVACV7T2-6WY5Q-48EWP-ZXY7X-QGUWDAALYG-20HVE-WHQ13-67MUP-XVMF3 3.Linux操作系统下载，这里选择CentOS。CentOS下载地址选择DVD ISO 进入CentOS下载页面，这里提供了很多的下载连接，选择其中一个下载即可。这里我选择了aliyun详细教程移驾一去丶二三里 4.接下来就是新建虚拟机了，根据版本自行百度图文教程安装即可，注意这里将SWAP分区分为sda2分区就不会出现下面7的情况了。分区原则：配置分区 –&gt; 标准分区 点击 + 添加挂载点/boot是系统挂载点，一般200Mb足够了。swap是交换内存，类似于window的虚拟内存。一般来说，swap的大小是真实内存的两倍。我们刚才的真实内存是1G,所以这里2G。/home是存放普通用户的数据，是普通用户的宿主目录，分配1G。/var ：用来存放 Linux 系统中经常变化的数据以及日志文件，建议大于 1GB 以上。再把剩下的空间分配给/(根目录)。centos-7的图文教程详细教程 CentOS 7 安装教程、硬盘分区、LVM、网络配置、软件源配置、制作 5.如果遇到 无法连接 MKS: 套接字连接尝试次数太多；正在放弃。5.1 打开控制面板—&gt;系统和安全—&gt;管理工具—-&gt;服务 查看VMware Authorization Service这个服务是否启动，我这里发现类型是自动，但是并没有正常启动，折腾了许久，怀疑权限不够然后执行5.25.2 关闭VMwate的所有进程然后以管理员身份运行VMware，正常启动。 6.VMware由于某些原因虚拟机并未启动，但是却显示正在运行，此时再次开机出现无法启动问题到相应的虚拟机目录下删除%虚拟机名字%.vmx.lck文件夹或者其中的文件即可，产生问题的原理：我们打开任务管理器，会发现vmware.exe和vmware-vmx.exe两个重要的进程。其中vmware-vmx.exe是主程序，虚拟机在这个进程下运行；VMware.exe是外壳程序，负责显示vmware-vmx.exe中运行的虚拟系统并解释传送各种命令和操作，是我们最常用的VMware用户界面，该程序可重入即同时打开多个。因为VMware Workstation是可重入的，为了避免同一个虚拟系统同时被多个VMware.exe打开操作，造成错误，所以每个VMware打开相应的虚拟机选项卡时都会先检查该虚拟机根目录下是否有*.vmx.lck的文件夹并验证其中的文件，如果该文件中包含合法生成的uuid（通用唯一识别码），那么将无法打开该虚拟机的选项卡。具体参见 VMWARE非法关闭的启动错误 登录界面报错 localhost login: [ 28.819381] sda2: WRITE SAME failed.Manually zeroing.由于CENTOS 7智能辅助分区，分多个分区的时候SWAP分区会乱窜，将SWAP分区分为sda2分区即解决问题。 8.命令行/图形界面安装 X Window System yum group install “X Window System” -y 不带-y会提示 Is This Ok[y/d/N] y = yes n = no d = download only (只下载不安装)这里为啥安装X Window，是因为其他的GNOME、MATE Desktop ali源没有卸载 X Window Systemyum group remove “GNOME Desktop Environment”systemctl get-default //获取当前系统启动模式systemctl set-default graphical.target 设置为图形界面模式systemctl set-default multi-user.target 设置为命令行多用户模式 检查已经安装的软件以及可以安装的软件，用命令yum grouplist]]></content>
      <categories>
        <category>Redis</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Tomcat内存优化]]></title>
    <url>%2Fblog%2F2018%2F04%2F10%2Ftomcat%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[Tomcat内存优化 JAVA_OPTS参数说明：-server 启用jdk 的 server 版-Xms JVM初始分配的最小堆内存 默认是物理内存的1/64-Xmx JVM最大允许分配的堆内存，按需分配 默认是物理内存的1/4-XX: PermSize 内存永久保留区域 JVM初始分配的非堆内存-XX:MaxPermSize 内存最大永久保留区域 JVM最大允许分配的非堆内存，按需分配 JVM初始分配的堆内存由-Xms指定，默认是物理内存的1/64；JVM最大分配的堆内存由-Xmx指定，默认是物理内存的1/4。默认空余堆内存小于40%时，JVM就会增大堆直到-Xmx的最大限制；空余堆内存大于70%时，JVM会减少堆直到-Xms的最小限制。因此服务器一般设置-Xms、-Xmx 相等以避免在每次GC 后调整堆的大小。 1.java.lang.OutOfMemoryError: Java heap space解释： Heap size 设置 JVM堆的设置是指java程序运行过程中JVM可以调配使用的内存空间的设置.JVM在启动的时候会自动设置Heap size的值，其初始空间(即-Xms)是物理内存的1/64，最大空间(-Xmx)是物理内存的1/4。可以利用JVM提供的-Xmn -Xms -Xmx等选项可进行设置。Heap size 的大小是Young Generation 和Tenured Generaion 之和。提示：在JVM中如果98％的时间是用于GC且可用的Heap size 不足2％的时候将抛出此异常信息。 Heap Size 最大不要超过可用物理内存的80％，一般的要将-Xms和-Xmx选项设置为相同，而-Xmn为1/4的-Xmx值。 2.java.lang.OutOfMemoryError: PermGen space 原因： PermGen space的全称是Permanent Generation space,是指内存的永久保存区域，这块内存主要是被JVM存放Class和Meta信息的,Class在被Loader时就会被放到PermGen space中，它和存放类实例(Instance)的Heap区域不同,GC(Garbage Collection)不会在主程序运行期对PermGen space进行清理，所以如果你的应用中有很CLASS的话,就很可能出现PermGen space错误 参考：内存溢出之Tomcat内存配置配置tomcat服务器内存大小中的Xms、Xmx、PermSize、MaxPermSize 详解 默认不设置情况下JVM信息如下（本机6G内存）：{“flag”:”Y”,”data”:{“totalMemory”:”390.00MB”,”maxMemory”:”1346.00MB”,”freeMemory”:”265.00MB”,”cpuNum”:4}} 在catalina.bat最前面增加 set JAVA_OPTS=-Xms128m -Xmx512m 用startup.bat启动tomcat。JVM信息如下{“flag”:”Y”,”data”:{“totalMemory”:”220.00MB”,”maxMemory”:”455.00MB”,”freeMemory”:”105.00MB”,”cpuNum”:4}}OK设置生效 利用windows的系统服务启动tomcat服务,上面的设置就不生效windows服务运行的是bin\tomcat.exe.他读取注冊表中的值,而不是catalina.bat的设置 如果遇到点击tomcat8.exe打不开，进入Tomcat\bin\安装目录，输入： service.bat install 即可。 cmd–&gt;services.msc(或 计算机–&gt;管理–&gt;服务和应用程序–&gt; 服务)，显示已经有Tomcat服务了。再次双击Tomcat8.exe，就可以运行了。JVM信息如下{“flag”:”Y”,”data”:{“totalMemory”:”153.00MB”,”maxMemory”:”228.00MB”,”freeMemory”:”111.00MB”,”cpuNum”:4}} 解决的方法: 改动注冊表 HKEY_LOCAL_MACHINE\SOFTWARE\Apache Software Foundation\Tomcat Service Manager\Tomcat5\Parameters\Java\Options找半天没注册表里找不到该信息，经查找说64位系统，tomcat的注册表信息是写在HKEY_LOCAL_MACHINE/SOFTWARE/Wow6432Node/Apache Software Foundation/Procrun 2.0/Tomcat8/Parameters/Java/Options 原值：-Dcatalina.home=F:\apache-tomcat-8.0.52-Dcatalina.base=F:\apache-tomcat-8.0.52-Dignore.endorsed.dirs=F:\apache-tomcat-8.0.52\endorsed-Djava.io.tmpdir=F:\apache-tomcat-8.0.52\temp-Djava.util.logging.manager=org.apache.juli.ClassLoaderLogManager-Djava.util.logging.config.file=F:\apache-tomcat-8.0.52\conf\logging.properties 经尝试，在Options后加入 -Xms128m -Xmx512m 没效果 ，JVM信息如下{“flag”:”Y”,”data”:{“totalMemory”:”154.00MB”,”maxMemory”:”228.00MB”,”freeMemory”:”111.00MB”,”cpuNum”:4}} 注册表信息 HKEY_LOCAL_MACHINE/SOFTWARE/Wow6432Node/Apache Software Foundation/Procrun 2.0/Tomcat8/Parameters/Java将 JVM的 jvmMs jvmMx 单独在外面设置了，所以只需该相应的值即可。重起tomcat服务,设置生效。JVM信息如下：{“flag”:”Y”,”data”:{“totalMemory”:”232.00MB”,”maxMemory”:”455.00MB”,”freeMemory”:”119.00MB”,”cpuNum”:4}}]]></content>
      <categories>
        <category>Tomcat</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[深入学习Redis]]></title>
    <url>%2Fblog%2F2018%2F04%2F10%2F%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0Redis%2F</url>
    <content type="text"><![CDATA[Redis学习—文章收集 文章列表 深入学习Redis（1）：Redis内存模型]]></content>
      <categories>
        <category>Redis</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Markdown语法]]></title>
    <url>%2Fblog%2F2018%2F04%2F04%2FMarkdown%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[Markdown 语法 标题 大标题 === 小标题 --- # 一级标题 ## 二级标题 ### 三级标题 #### 四级标题 ##### 五级标题 ###### 六级标题 注意在#和标题之间要有一个空格 *斜体文本* _斜体文本_ **粗体文本** __粗体文本__ ***粗斜体文本*** ___粗斜体文本___ 斜体文本 斜体文本粗体文本 粗体文本粗斜体文本 粗斜体文本 链接常用链接方法 文字链接 [my blog](https://759716722.github.io/blog/) 网址链接 https://759716722.github.io/blog/ 可用包裹，也可不包裹 文字链接 my blog网址链接 https://759716722.github.io/blog/ 高级链接技巧 这个链接用 1 作为网址变量 [Baidu][1]. 这个链接用 baidu 作为网址变量 [Baidu!][baidu]. 然后在文档的结尾为变量赋值（网址） 注意:后面加不加空格都可,但每个网址前需空出一行,否则不能正常引用 [1]: https://www.baidu.com/ [baidu]: https://www.baidu.com/ 这个链接用 1 作为网址变量 Baidu.这个链接用 Baidu 作为网址变量 Baidu!. 列表普通无序列表 - 列表文本前使用 [减号+空格] + 列表文本前使用 [加号+空格] * 列表文本前使用 [星号+空格] 列表文本前使用 [减号+空格] 列表文本前使用 [加号+空格] 列表文本前使用 [星号+空格] 普通有序列表 1. 列表前使用 [数字+空格] 2. 我们会自动帮你添加数字 7. 不用担心数字不对，显示的时候我们会自动把这行的 7 纠正为 3 列表前使用 [数字+空格] 我们会自动帮你添加数字 不用担心数字不对，显示的时候我们会自动把这行的 7 纠正为 3 列表嵌套 1. 列出所有元素： - 无序列表元素 A 1. 元素 A 的有序子列表 实际使用发现无序列下有序子列表失效 - 前面加四个空格 2. 列表里的多段换行： 前面必须加四个空格， 实际使用发现可以随便空0-6格，超过6个会引入代码块 这样换行，整体的格式不会乱 7. 列表里引用： > 前面空一行 实际使用发现可以不空行，也可以不加四个空格 > 仍然需要在 > 前面加四个空格 4. 列表里代码段： 前面四个空格，之后按三个`的代码语法书写 或者直接空八个，引入代码块 列出所有元素： 无序列表元素 A 元素 A 的有序子列表 实际使用发现无序列下有序子列表失效 前面加四个空格 列表里的多段换行： 前面必须加四个空格， 实际使用发现可以随便空0-6格，超过6个会引入代码块 这样换行，整体的格式不会乱 列表里引用： 前面空一行 实际使用发现可以不空行，也可以不加四个空格仍然需要在 &gt; 前面加四个空格 列表里代码段： 1前面四个空格，之后按代码语法 ``` 书写 或者直接空八个，引入代码块 引用普通引用 > 引用文本前使用 [大于号+空格] > 折行可以不加，新起一行都要加上哦 引用文本前使用 [大于号+空格]折行可以不加，新起一行都要加上哦 引用里嵌套引用 > 最外层引用 > > 多一个 > 嵌套一层引用 > > > 可以嵌套很多层 最外层引用 多一个 &gt; 嵌套一层引用 可以嵌套很多层 引用里嵌套列表 > - 这是引用里嵌套的一个列表 > - 还可以有子列表 > * 子列表需要从 - 之后延后四个空格开始 这是引用里嵌套的一个列表 还可以有子列表 子列表需要从 - 之后延后四个空格开始 图片跟链接的方法区别在于前面加了个感叹号! 网址引用 ![小清新](https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1522833977957&di=ab27eb3364565567103ac9a075eea083&imgtype=0&src=http%3A%2F%2Fp3.wmpic.me%2Farticle%2F2017%2F11%2F28%2F1511834156_hrPeEMeP.jpg) 本地引用 ![小清新](../../../../imgs/loading.gif) 当然，你也可以像网址那样对图片网址使用变量 这个链接用 2 作为网址变量 [Google][2]. 因为上面已经用1作变量了，所以这里用2，不然引用的还是1的网址 然后在文档的结尾位变量赋值(网址) [2]: https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1522833977957&di=ab27eb3364565567103ac9a075eea083&imgtype=0&src=http%3A%2F%2Fp3.wmpic.me%2Farticle%2F2017%2F11%2F28%2F1511834156_hrPeEMeP.jpg 网址引用本地引用这个链接用 2 作为图片网址变量 小清新. 也可以使用 HTML 的图片语法来自定义图片的宽高大小 分隔符 如果你有写分割线的习惯，可以新起一行输入三个减号-。 注意一定是新起一行输入三个减号-，不然会识别为小标题 前面的段落 --- 后面的段落 前面的段落 后面的段落 小型文本1&lt;small&gt;文本内容&lt;/small&gt; 文本内容 注释1&lt;!-- 注释 --&gt; 表格 | 参数 | 说明 | 默认值 | | ------------- |:-------------------:|:------------------:| | host | 远程主机的地址 | | | user | 使用者名称 | | | root | 远程主机的根目录 | | | port | 端口 | 22 | | delete | 删除远程主机上的旧文件 | true | | verbose | 显示调试信息 | true | | ignore_errors | 忽略错误 | false | 参数 说明 默认值 host 远程主机的地址 user 使用者名称 root 远程主机的根目录 port 端口 22 delete 删除远程主机上的旧文件 true verbose 显示调试信息 true ignore_errors 忽略错误 false 代码1234567高亮语句中的某个函数名或关键字，可以使用`function_name()`实现代码块可以使用如下方式 ``` JavaScript 注意```和语言名称中间有空格$(document).ready(function () &#123; alert(&apos;hello world&apos;);&#125;);注意这里结束有3个点，因为会被识别，所以用“3个点”代替 function_name() 123$(document).ready(function () &#123; alert('hello world');&#125;);]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[使用Hexo遇到的问题]]></title>
    <url>%2Fblog%2F2018%2F03%2F26%2F%E4%BD%BF%E7%94%A8Hexo%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[使用Hexo过程中的问题收集 如果是代理问题把代理去掉就行了npm config set proxy null 如果是npm源有问题则使用淘宝npm源npm install -g cnpm –registry=https://registry.npm.taobao.orgcnpm install hexo-cli -g 如果出现cnpm不是外部命令因为我之前更改了全局模块安装的路径，因此找不到cnpm的可执行文件，需要配置下环境变量即可在系统变量 的 PATH下 加入 cnpm.cmd 所在路径E:\Program Files\nodejs\node_modules\npm\node_global_modules 如果不使用淘宝npm源也能成功下载hexo,但是出现hexo不是外部命令原因同上更改了全局模块安装的路径在系统变量 的 PATH下 加入 cnpm.cmd 所在路径E:\Program Files\nodejs\node_modules\npm\node_global_modules Deployer not found: git原因是还需要安装一个插件： npm install hexo-deployer-git hexo g 生成的时候报错原因冒号后面必须有一个空格 git下载主题，无法克隆,错误大体描述为“error setting certificate verify locations”git clone的时候出现一个错误，导致无法克隆成功，错误大体描述为“error setting certificate verify locations”，翻译为错误设置证书验证位置，看了本地\Git\mingw64\ssl\certs 下面确实有证书。这个错误是系统证书的问题，系统判断到这个行为会造成不良影响，所以进行了阻止，只要设置跳过SSL证书验证就可以了，用命令 ： git config –global http.sslVerify false设置完成后继续clone，就可以了。 在本地server成功，显示没有问题，但是部署到github上之后，就无法显示主题和图片了更改一下_config.yml文件，其中的url和root属性。 url: https://759716722.github.io/blog/ root: /blogroot 下面应该设置成 /你的项目名 而不是/，然后重新部署一下就成功了。 分类栏目不展示分类目录，是因为新建的categories的index.md 未加入 type: “categories” ，导致无法显示分类目录，标签也一样 图片引用出不来本来以为是因为站点配置文件的post_asset_folder选项没有打开，结果不是因为这个问题，post_asset_folder设置为true则每新建一遍文章都会新建相应的资源文件夹，所以不采用这种图片引用采用的是相对路径，因此引用时必须要到相应的目录，通过public目录可以知道文章的页面目录为：public\2018\04\04\文章名\引用图片为 ： ![小清新](../../../../imgs/loading.gif) 打开文章的更新时间搜索 post_meta 将 updated_at 设置为true 打开文章的 字数统计、阅读时间功能搜索 post_wordcount 将 wordcount、min2read 设置为 true然后下载 hexo-wordcount 此时我们不进行全局安装，安装在hexo的模块下即可指令： npm install hexo-wordcount NexT主题自带canvas-nest背景效果不能设置颜色、线条的个数等可以通过修改_layout.swig，外部引用 canvas-nest.min.js 实现打开next/layout/_layout.swig 在之前添加代码(注意不要放在&lt; /head&gt;的后面)&lt;script type=&quot;text/javascript&quot; color=&quot;0,0,255&quot; opacity=&#39;0.7&#39; zIndex=&quot;-2&quot; count=&quot;99&quot; src=&quot;//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js&quot;&gt;&lt;/script&gt;color ：线条颜色, 默认: ‘0,0,0’；三个数字分别为(R,G,B)opacity: 线条透明度（0~1）, 默认: 0.5count: 线条的总数量, 默认: 150zIndex: 背景的z-index属性，css属性用于控制所在层的位置, 默认: -1注意这里的zIndex只能比-1小，不然会遮住页面所有点击都无法实现 修改背景的透明度通过查看生成的页面HTML的结构，我们会发现侧面导航栏和内容分别引用了 header-inner 和 main-inner 两个class属性，因此我们只需要在 themes\next\source\css_custom\custom.styl 文件中加入如下代码： 123456789101112131415.header-inner &#123; opacity: 0.8; //透明度&#125;.main-inner &#123; opacity: 0.8;&#125;// 如果想加入背景图则添加以下代码,注意背景图的引用位置是你存放的位置，如果发布后引用不到，那么就自己去public文件夹下找到css// 然后算出放图片的文件夹和这个文件夹的相对路径body &#123; background-image: url(../imgs/background.jpg); background-attachment: fixed; // 不随屏幕滚动而滚动 background-repeat: repeat; // 如果背景图不够屏幕大小则重复铺，改为no-repeat则表示不重复铺 background-size: contain; // 等比例铺满屏幕&#125; NexT主题配置 http://theme-next.iissnan.com/theme-settings.html NexT主题优化 https://segmentfault.com/a/1190000013660164]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2Fblog%2F2018%2F03%2F26%2FHello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
  </entry>
</search>
